<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Logic → Text — Geology (EN/HU)</title>
  <style>
    :root { --radius: 12px; --gap: 12px; --pad: 14px; --bg:#0b1220; --card:#121a2e; --ink:#e7eefc; --muted:#9fb0d4; --accent:#86b7ff; --err:#ff9b9b; --ok:#9be3ac; }
    html, body { height:100%; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans"; }
    .wrap { max-width: 960px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 1.5rem; margin: 0 0 6px; }
    .sub { color:var(--muted); margin-bottom:16px; }
    .card { background: var(--card); border: 1px solid #1d2744; border-radius: var(--radius); padding: var(--pad); }
    .grid { display:grid; gap:var(--gap); }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pill { padding: 6px 10px; border-radius:999px; background:#16203a; border:1px solid #273658; cursor:pointer; }
    .pill.active { background:#223059; }
    .btn { padding: 8px 12px; border-radius: 10px; background:#1a2441; color:var(--ink); border:1px solid #2a3968; cursor:pointer; }
    .btn:hover { background:#223059; }
    .btn.small { padding: 6px 8px; font-size: .9rem; }
    .field { width:100%; padding:10px 12px; border-radius:10px; border:1px solid #2a3968; background:#0e1528; color:var(--ink); }
    .field.err { border-color: #5a1b1b; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .muted { color:var(--muted); }
    .hint { color:var(--muted); font-size:.92rem; }
    .ok { color: var(--ok); }
    .err { color: var(--err); }
    table { width:100%; border-collapse:collapse; }
    th,td { border-bottom:1px solid #223059; padding:6px 8px; text-align:left; }
    .kbd { padding: 4px 8px; background:#0f1832; border:1px dashed #2a3968; border-radius:8px; }
  </style>
</head>
<body>
  <div class="wrap grid">
    <div class="row" style="justify-content:space-between;">
      <div>
        <h1>Logic → Text</h1>
        <div class="sub">Geology domain • <span id="langLabel">English</span> / Magyar</div>
      </div>
      <div class="row" role="group" aria-label="Language toggle">
        <button class="pill" id="langEn" aria-pressed="true">EN</button>
        <button class="pill" id="langHu" aria-pressed="false">HU</button>
      </div>
    </div>

    <div class="card grid">
      <div class="row"><strong>Variables</strong><span class="muted">&nbsp;(edit meanings)</span></div>
      <div class="grid" style="grid-template-columns: repeat(3, 1fr);">
        <div><div class="muted mono">p</div><input class="field" id="vp"></div>
        <div><div class="muted mono">q</div><input class="field" id="vq"></div>
        <div><div class="muted mono">r</div><input class="field" id="vr"></div>
        <div><div class="muted mono">o</div><input class="field" id="vo"></div>
        <div><div class="muted mono">y</div><input class="field" id="vy"></div>
        <div><div class="muted mono">i</div><input class="field" id="vi"></div>
      </div>
      <div class="hint" id="hintTxt"></div>
    </div>

    <div class="card grid">
      <div class="row" style="justify-content:space-between;">
        <strong>Build with symbols</strong>
        <div class="row">
          <button class="btn small" id="clearBtn">Clear</button>
          <button class="btn small" id="copyBtn">Copy text</button>
        </div>
      </div>
      <div class="row">
        <button class="btn mono" data-insert="p">p</button>
        <button class="btn mono" data-insert="q">q</button>
        <button class="btn mono" data-insert="r">r</button>
        <button class="btn mono" data-insert="o">o</button>
        <button class="btn mono" data-insert="y">y</button>
        <button class="btn mono" data-insert="i">i</button>
        <span style="width:16px"></span>
        <button class="btn mono" data-insert=",">¬</button>
        <button class="btn mono" data-insert="`">∧</button>
        <button class="btn mono" data-insert="~">∨</button>
        <button class="btn mono" data-insert="→">→</button>
        <button class="btn mono" data-insert="↔">↔</button>
        <button class="btn mono" data-insert="(">(</button>
        <button class="btn mono" data-insert=")">)</button>
      </div>

      <div>
        <div class="muted">Expression</div>
        <input id="expr" class="field mono" placeholder="Type or click buttons…">
      </div>

      <div>
        <div class="muted">Reading</div>
        <div id="reading" class="hint">—</div>
      </div>

      <div>
        <div class="muted">Examples (click to load)</div>
        <div id="examples" class="row"></div>
      </div>
    </div>

    <div class="card">
      <details>
        <summary class="muted">Legend</summary>
        <div class="grid" style="margin-top:8px">
          <div><span class="kbd mono">¬</span> NOT (ASCII <span class="mono">,</span>)</div>
          <div><span class="kbd mono">∧</span> AND (ASCII <span class="mono">`</span>)</div>
          <div><span class="kbd mono">∨</span> OR (ASCII <span class="mono">~</span>)</div>
          <div><span class="kbd mono">→</span> implies (ASCII <span class="mono">-></span>)</div>
          <div><span class="kbd mono">↔</span> iff (ASCII <span class="mono"><-></span>)</div>
          <div>Parentheses group as usual.</div>
        </div>
      </details>
    </div>
  </div>

<script>
// ---------- Config (fetched once) ----------
let CFG = null;
fetch("/logic-text/api/config").then(r=>r.json()).then(cfg => {
  CFG = cfg;
  setLang("en");
  // examples
  const exWrap = document.getElementById("examples");
  cfg.examples.forEach((ex, idx) => {
    const b = document.createElement("button");
    b.className = "btn small mono";
    b.textContent = ex.expr;
    b.title = ex.en;
    b.onclick = () => { setExpr(ex.expr); };
    exWrap.appendChild(b);
  });
});

// ---------- Helpers ----------
const $ = id => document.getElementById(id);
function setExpr(s){ $("expr").value = s; onExprInput(); }

// Language toggle
$("langEn").onclick = () => setLang("en");
$("langHu").onclick = () => setLang("hu");
function setLang(l){
  if (!CFG) return;
  const en = l==="en";
  $("langEn").classList.toggle("active", en);
  $("langHu").classList.toggle("active", !en);
  $("langEn").setAttribute("aria-pressed", en);
  $("langHu").setAttribute("aria-pressed", !en);
  $("langLabel").textContent = en ? "English" : "Magyar";
  const def = en ? CFG.vars.default_en : CFG.vars.default_hu;
  $("vp").value = def.p; $("vq").value = def.q; $("vr").value = def.r;
  $("vo").value = def.o; $("vy").value = def.y; $("vi").value = def.i;
  $("hintTxt").textContent = (en ? CFG.hints.en : CFG.hints.hu);
  document.documentElement.lang = en ? "en" : "hu";
  window.APP_LANG = l;
  onExprInput();
}

// keypad
document.querySelectorAll("[data-insert]").forEach(btn => {
  btn.addEventListener("click", () => {
    const ch = btn.getAttribute("data-insert") || "";
    const input = $("expr");
    const s = input.selectionStart ?? input.value.length;
    const e = input.selectionEnd ?? input.value.length;
    input.value = input.value.slice(0,s) + ch + input.value.slice(e);
    input.focus();
    input.selectionStart = input.selectionEnd = s + ch.length;
    onExprInput();
  });
});
$("clearBtn").onclick = () => { $("expr").value=""; onExprInput(); };
$("copyBtn").onclick  = async () => {
  const txt = $("reading").innerText;
  if (txt && txt !== "—") { try { await navigator.clipboard.writeText(txt); } catch(e){} }
};

// ---------- Parser (client-side, no server roundtrip) ----------
// Normalize: strip spaces, lowercase vars, map aliases, convert -> and <->
function normalize(expr){
  let s = (expr || "").trim();
  if (!s) return s;
  s = s.replace(/<->/g, "↔").replace(/->/g, "→");
  s = s.replace(/\s+/g, "").toLowerCase();
  // map unicode aliases to ascii placeholders (consistent with your autograder)
  s = s.replace(/¬/g, ",");
  s = s.replace(/∧/g, "`");
  s = s.replace(/∨/g, "~");
  // validate allowed characters
  const allowed = new Set("pqroiy(),`~→↔");
  for (const ch of s){
    if (!allowed.has(ch)) throw new Error("Use only p,q,r,o,y,i, parentheses, ¬ ∧ ∨ → ↔ (or ASCII ',', '`', '~', ->, <->).");
  }
  return s;
}

function tokenize(s){
  const out = [];
  for (const c0 of s){
    let c = c0;
    if ("pqroiy".includes(c)) out.push(["VAR", c]);
    else if (c === ",") out.push(["NOT", c]);
    else if (c === "`") out.push(["AND", c]);
    else if (c === "~") out.push(["OR",  c]);
    else if (c === "→") out.push(["IMP", c]);
    else if (c === "↔") out.push(["IFF", c]);
    else if (c === "(") out.push(["LPAREN", c]);
    else if (c === ")") out.push(["RPAREN", c]);
    else throw new Error("Unexpected character: " + c);
  }
  return out;
}

const PREC = { IFF:1, IMP:2, OR:3, AND:4, NOT:5 };
const ASSOC = { IFF:"R", IMP:"R", OR:"L", AND:"L", NOT:"R" };

function toRPN(tokens){
  const output = [], ops = [];
  for (const [tok, val] of tokens){
    if (tok === "VAR") output.push([tok, val]);
    else if (tok === "NOT") ops.push([tok, val]);
    else if (["AND","OR","IMP","IFF"].includes(tok)){
      while (ops.length && ops[ops.length-1][0] !== "LPAREN"){
        const top = ops[ops.length-1][0];
        const condL = (ASSOC[tok]==="L" && PREC[top] >= PREC[tok]);
        const condR = (ASSOC[tok]==="R" && PREC[top] >  PREC[tok]);
        if (condL || condR) output.push(ops.pop());
        else break;
      }
      ops.push([tok, val]);
    } else if (tok === "LPAREN") ops.push([tok, val]);
    else if (tok === "RPAREN"){
      while (ops.length && ops[ops.length-1][0] !== "LPAREN"){
        output.push(ops.pop());
      }
      if (!ops.length) throw new Error("Mismatched parentheses.");
      ops.pop(); // pop LPAREN
    }
  }
  while (ops.length){
    if (["LPAREN","RPAREN"].includes(ops[ops.length-1][0])) throw new Error("Mismatched parentheses.");
    output.push(ops.pop());
  }
  return output;
}

function rpnToAst(rpn){
  const st = [];
  for (const [tok, sym] of rpn){
    if (tok === "VAR") st.push({ op:"VAR", val:sym });
    else if (tok === "NOT"){
      if (!st.length) throw new Error("Missing operand for NOT.");
      st.push({ op:"NOT", left: st.pop() });
    } else { // binary
      if (st.length < 2) throw new Error("Missing operands for binary operator.");
      const b = st.pop(); const a = st.pop();
      st.push({ op:tok, left:a, right:b });
    }
  }
  if (st.length !== 1) throw new Error("Malformed expression.");
  return st[0];
}

function prec(op){ return ({ IFF:1, IMP:2, OR:3, AND:4, NOT:5, VAR:6 })[op] || 0; }

function phrase(node, dict, lang){
  if (node.op === "VAR") return dict[node.val] || node.val;
  if (node.op === "NOT"){
    const x = phrase(node.left, dict, lang);
    const s = (lang==="en" ? "not " + x : "nem " + x);
    return (node.left.op === "VAR") ? s : "(" + s + ")";
  }
  const left  = phrase(node.left,  dict, lang);
  const right = phrase(node.right, dict, lang);
  const conn = (lang==="en"
    ? {AND:"{a} and {b}", OR:"{a} or {b}", IMP:"if {a}, then {b}", IFF:"{a} if and only if {b}"}
    : {AND:"{a} és {b}",  OR:"{a} vagy {b}", IMP:"ha {a}, akkor {b}", IFF:"{a} akkor és csak akkor, ha {b}"}
  );
  function maybeParen(child, frag){
    if (child.op === "VAR") return frag;
    return prec(child.op) < prec(node.op) ? "(" + frag + ")" : frag;
  }
  const a = maybeParen(node.left, left);
  const b = maybeParen(node.right, right);
  return conn[node.op].replace("{a}", a).replace("{b}", b);
}

// ---------- Live behavior ----------
$("expr").addEventListener("input", onExprInput);

function collectVars(){
  return { p:$("vp").value, q:$("vq").value, r:$("vr").value, o:$("vo").value, y:$("vy").value, i:$("vi").value };
}

function onExprInput(){
  const expr = $("expr").value;
  if (!expr.trim()){
    $("reading").textContent = "—";
    $("expr").classList.remove("err");
    return;
  }
  try{
    const norm = normalize(expr);
    const tokens = tokenize(norm);
    const rpn = toRPN(tokens);
    const ast = rpnToAst(rpn);
    const vars = collectVars();
    const lang = (window.APP_LANG || "en");
    const text = phrase(ast, vars, lang);
    $("reading").innerText = text;
    $("expr").classList.remove("err");
  }catch(e){
    $("reading").innerHTML = '<span class="err">' + e.message + '</span>';
    $("expr").classList.add("err");
  }
}

// bootstrap
window.APP_LANG = "en";
</script>
</body>
</html>
