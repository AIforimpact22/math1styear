<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Geology Set Theory Simulator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg: #0b0f14;
      --card:#121821;
      --ink:#e8f0ff;
      --muted:#9fb2c7;
      --accent:#7aa2ff;
      --ring: rgba(122,162,255,0.3);
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 70% -10%, #17202b 0%, var(--bg) 55%) no-repeat fixed;
      color: var(--ink);
      font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    /* ---- Header (University of Szeged block) ---- */
    header{
      position: sticky; top: 0; z-index: 20;
      background: linear-gradient(135deg, #101828 0%, #0b0f14 60%);
      border-bottom: 1px solid #1f2a36;
    }
    .wrap{ max-width: 1200px; margin: 0 auto; padding: 12px 16px; }
    .header-top{
      display: flex; align-items: center; justify-content: space-between;
      gap: 16px; flex-wrap: wrap;
    }
    .title{ display:flex; flex-direction:column; gap:6px; min-width: 260px; }
    .title .badge{
      display:inline-flex; gap:6px; align-items:center; padding:4px 8px; border-radius:999px;
      background:#0d1320; border:1px solid #263243; font-size:12px; color:#9fb2c7;
      width: fit-content;
    }
    .title h1{ font-size:18px; line-height:1.25; margin:0; font-weight:700; color:#dbe6ff; }
    header h2{
      margin:10px 0 8px; font-size:16px; font-weight:600; color:#cbd7ea;
    }
    .logo-row{ display:flex; align-items:center; gap:10px; }
    .logo-chip{
      display:inline-flex; align-items:center; justify-content:center;
      background:#0d1320; border:1px solid #263243; border-radius:10px;
      padding:6px 8px;
    }
    .logo-chip img{ display:block; height:34px; width:auto; }

    /* Controls row under header */
    .controls{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      margin-top: 6px;
    }

    /* ---- Buttons, chips, layout ---- */
    .btn, .chip, label.switch{
      display:inline-flex; align-items:center; gap:8px;
      background: #17202b; color: var(--ink); border:1px solid #233040;
      padding: 8px 10px; border-radius:10px; cursor:pointer; user-select:none;
    }
    .btn:hover{ border-color:#2b3a4f; background:#0f141c; }
    .btn:active{ transform: translateY(1px); }
    .chip{ font-size:12px; padding:6px 8px; border-radius:999px; }
    .chip .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid #0e1523; }
    .chip small{ color: var(--muted); }

    /* Main two-column layout: left canvas + right sidebar; explanation sits under canvas */
    main{ display:grid; grid-template-columns: 1fr 360px; gap:16px; max-width: 1200px; margin: 12px auto; padding: 0 16px 16px; }
    @media (max-width: 980px){ main{ grid-template-columns: 1fr; } }

    .canvas-card{ position: relative; background: var(--card); border:1px solid #233040; border-radius:14px; overflow:hidden; }
    .canvas-head{
      position:absolute; left:12px; top:12px; display:flex; gap:8px; align-items:center; z-index:5;
      background: rgba(18,24,33,0.75); border:1px solid #233040; padding:6px 8px; border-radius:10px;
    }
    .canvas-hint{
      position:absolute; right:12px; top:12px; z-index:5;
      background: rgba(18,24,33,0.75); border:1px solid #233040; padding:6px 8px; border-radius:10px; color:#cfd8e3;
    }
    .hl-chip{
      position:absolute; left:12px; bottom:12px; z-index:6;
      background: rgba(18,24,33,0.9); border:1px solid #705e20; padding:8px 10px; border-radius:10px;
      box-shadow: 0 0 0 2px rgba(255,213,74,0.2) inset;
      color:#ffeaa0; font-weight:600; max-width: calc(100% - 24px);
    }
    canvas{ width:100%; height:66vh; display:block; }

    aside{
      background: var(--card);
      border:1px solid #233040; border-radius:14px; padding:12px;
      display:flex; flex-direction:column; gap:12px; min-height: 66vh;
      grid-row: span 2; /* keep sidebar spanning both rows */
    }
    aside h2{ font-size:14px; margin:0 0 6px; color:#cbd7ea; }

    .summary{ display:grid; gap:8px; }
    .summary .row{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:6px 8px; border:1px dashed #2a394e; border-radius:10px; cursor:pointer;
      transition: background 0.15s ease, border-color 0.15s ease;
    }
    .summary .row:hover{ background:#0f141c; }
    .summary .row .lhs{ display:flex; align-items:center; gap:8px; }
    .summary .row code{
      background:#0d1320; border:1px solid #263243; padding:2px 6px; border-radius:6px; color:#a9c3ff;
    }
    .row.subhead{
      cursor:default; background:#0d1320; border:1px solid #263243;
      color:#9fb2c7; font-weight:600; justify-content:flex-start;
    }
    .row.selected{
      border-color: rgba(255,213,74,0.9);
      background: rgba(255,213,74,0.10);
    }
    .k{ text-align:center; font-variant-numeric: tabular-nums; color:#cfe0ff; }

    table{
      width:100%; border-collapse: collapse; border:1px solid #233040; border-radius: 10px; overflow:hidden;
    }
    thead th{
      background:#0d1320; color:#9fb2c7; font-weight:600; font-size:12px; padding:8px; text-align:left; border-bottom:1px solid #233040;
    }
    tbody td{
      border-bottom:1px solid #1e2a3a; padding:6px 8px; font-size:13px;
      white-space:nowrap; text-overflow:ellipsis; overflow:hidden;
    }
    tbody tr:hover{ background:#0f141c; }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; color:#cbd7ea; }
    .help-list{ margin:6px 0 0 18px; color:var(--muted); }
    .help-list li{ margin:2px 0; }

    /* Explanation card (text response below canvas) */
    .explain-card{
      background: var(--card);
      border:1px solid #233040; border-radius:14px; padding:12px; min-height: 140px;
    }
    .explain-head{
      display:flex; flex-wrap:wrap; align-items:center; gap:10px; margin-bottom:8px;
    }
    .explain-head .badge{
      display:inline-flex; gap:6px; align-items:center; padding:4px 8px; border-radius:999px;
      background:#0d1320; border:1px solid #263243; font-size:12px; color:#9fb2c7;
    }
    .explain-head code{
      background:#0d1320; border:1px solid #263243; padding:2px 6px; border-radius:6px; color:#a9c3ff;
    }
    .explain-body{ color:#d7e6ff; }
    .exp-list{ margin:8px 0 0 18px; }
    .exp-list li{ margin:2px 0; }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="header-top">
      <div class="title">
        <span class="badge">University of Szeged</span>
        <h1>Department of Atmospheric and Geospatial Data Science</h1>
      </div>
      <div class="logo-row" aria-label="Department and University logos">
        <span class="logo-chip" title="Department logo">
          <img src="https://geosci.u-szeged.hu/site/upload/2024/10/logo_v2_2_64x55.png"
               alt="Department of Atmospheric and Geospatial Data Science logo" />
        </span>
        <span class="logo-chip" title="SZTE logo">
          <img src="https://u-szeged.hu/site/design3/img/szte_logo_en.jpg"
               alt="University of Szeged logo (English)" />
        </span>
      </div>
    </div>
    <h2>ABDULHAQ Hawkar — Set Theory (Slide 2)</h2>

    <!-- Controls -->
    <div class="controls" aria-label="Simulation controls">
      <button id="btnReset" class="btn">Reset</button>
      <button id="btnSave" class="btn">Save JSON</button>
      <label class="btn" for="fileLoad">Load JSON</label>
      <input id="fileLoad" type="file" accept="application/json" />
      <label class="switch btn"><input id="lockSets" type="checkbox" /> Lock Sets</label>
      <label class="switch btn"><input id="lockElements" type="checkbox" /> Lock Elements</label>
      <label class="switch btn"><input id="showLabels" type="checkbox" checked /> Show Element Labels</label>
    </div>
  </div>
</header>

<main>
  <!-- Left column, row 1 -->
  <section class="canvas-card" aria-label="Universe canvas">
    <div class="canvas-head">
      <span class="badge">Universe: <strong id="uName">…</strong></span>
      <span class="kbd">Tip:</span><span class="pill">Drag sets &amp; elements • Wheel over a set to resize</span>
    </div>
    <div class="canvas-hint">
      <span class="pill">Click any row to highlight region • Press <span class="kbd">Esc</span> to clear</span>
    </div>
    <div id="hlChip" class="hl-chip" style="display:none;"></div>
    <canvas id="venn" role="img" aria-label="Interactive Venn canvas"></canvas>
  </section>

  <!-- Right column, spans both rows -->
  <aside>
    <div>
      <h2>Sets</h2>
      <div id="setsChips" style="display:flex; flex-wrap:wrap; gap:6px;"></div>
    </div>

    <div class="summary" id="regions">
      <h2>Regions &amp; Intersections</h2>
      <!-- Filled dynamically -->
    </div>

    <div>
      <h2>Elements &amp; Membership</h2>
      <div style="overflow:auto; max-height: 38vh; border-radius:12px;">
        <table aria-label="elements membership table">
          <thead>
            <tr id="theadRow">
              <th>Element</th>
              <!-- set names added dynamically -->
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
      <ul class="help-list">
        <li>Drag rock labels to reposition. Membership is geometric: a label is in a set if it falls inside that circle.</li>
        <li>Click any row in “Regions &amp; Intersections” to spotlight that region; press <span class="kbd">Esc</span> to clear.</li>
      </ul>
    </div>
  </aside>

  <!-- Left column, row 2: Text explanation panel -->
  <section class="explain-card" aria-live="polite" aria-label="Text explanation for selected region">
    <div class="explain-head">
      <span class="badge">Selected region</span>
      <code id="expExpr">—</code>
      <span class="pill" id="expCount">(0 elements)</span>
    </div>
    <div class="explain-body" id="expText">
      Click a region in the right panel to see a description and the elements that belong to it.
      In this geology context, sets represent rock categories; an item belongs to a set if its label lies inside that circle.
    </div>
    <div class="explain-body" id="expElements" style="display:none;">
      <strong>Elements in region:</strong>
      <ul class="exp-list" id="expList"></ul>
    </div>
  </section>
</main>

<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist = (x1,y1,x2,y2) => Math.hypot(x1-x2, y1-y2);
  const hexToRgb = (hex) => {
    const h = hex.replace("#","").trim();
    const n = parseInt(h.length === 3 ? h.split("").map(c=>c+c).join("") : h, 16);
    return {r:(n>>16)&255, g:(n>>8)&255, b:n&255};
  };
  const rgbToHex = ({r,g,b}) => "#" + [r,g,b].map(v => v.toString(16).padStart(2,"0")).join("");
  const mixColors = (hexes) => {
    if (!hexes.length) return "#95a3b8";
    let r=0,g=0,b=0; hexes.forEach(h=>{ const c=hexToRgb(h); r+=c.r; g+=c.g; b+=c.b; });
    const n = hexes.length;
    return rgbToHex({r:Math.round(r/n), g:Math.round(g/n), b:Math.round(b/n)});
  };
  const hexToRgba = (hex, a) => { const {r,g,b} = hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; };

  // ---------- State ----------
  const canvas = document.getElementById("venn");
  const ctx = canvas.getContext("2d");
  const hlChip = document.getElementById("hlChip");
  const expExpr = document.getElementById("expExpr");
  const expCount = document.getElementById("expCount");
  const expText = document.getElementById("expText");
  const expElemsBlock = document.getElementById("expElements");
  const expList = document.getElementById("expList");

  const state = {
    universe: {name:"", width:1200, height:750},
    sets: [],
    elements: [],
    drag: null,
    needsDraw: true,
    highlight: null // {kind:'single'|'pair'|'diff'|'triple'|'outside'|'all', indices:[...]}
  };

  // ---------- Responsive canvas ----------
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    requestDraw();
  }
  const S = () => Math.min(canvas.clientWidth, canvas.clientHeight);
  const pxX = nx => nx * canvas.clientWidth;
  const pxY = ny => ny * canvas.clientHeight;
  const nX  = px => clamp(px / canvas.clientWidth, 0, 1);
  const nY  = py => clamp(py / canvas.clientHeight, 0, 1);

  // ---------- Hit test ----------
  function pickAt(px,py){
    for (let i=state.elements.length-1; i>=0; --i){
      const e = state.elements[i];
      if (dist(px,py,pxX(e.x),pxY(e.y)) <= 10) return {type:"element", index:i};
    }
    for (let i=state.sets.length-1; i>=0; --i){
      const s = state.sets[i];
      if (dist(px,py,pxX(s.x),pxY(s.y)) <= s.r * S()) return {type:"set", index:i};
    }
    return null;
  }

  // ---------- Membership & tallies ----------
  function memberships(){
    const n = state.sets.length;
    const counts = new Uint32Array(1<<n);
    const per = new Array(state.elements.length).fill(0);
    const centers = state.sets.map(s => ({cx:pxX(s.x), cy:pxY(s.y), r:s.r*S()}));

    for (let ei=0; ei<state.elements.length; ei++){
      const e = state.elements[ei];
      const ex = pxX(e.x), ey = pxY(e.y);
      let mask = 0;
      for (let si=0; si<n; si++){
        const {cx,cy,r} = centers[si];
        if (dist(ex,ey,cx,cy) <= r) mask |= (1<<si);
      }
      per[ei] = mask;
      counts[mask] += 1;
    }

    const total = state.elements.length;
    const singles = new Array(n).fill(0);
    for (let i=0;i<n;i++){
      let sum=0;
      for (let m=0;m<counts.length;m++) if (m & (1<<i)) sum += counts[m];
      singles[i]=sum;
    }

    const pairs = [];
    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++){
      let sum=0, need=(1<<i)|(1<<j);
      for (let m=0;m<counts.length;m++) if ((m & need) === need) sum += counts[m];
      pairs.push({i,j,count:sum});
    }

    const diffs = [];
    for (let i=0;i<n;i++){
      for (let j=0;j<n;j++){
        if (i===j) continue;
        let sum=0;
        for (let m=0;m<counts.length;m++){
          if ((m & (1<<i)) && !(m & (1<<j))) sum += counts[m];
        }
        diffs.push({i,j,count:sum});
      }
    }

    const triples = [];
    if (n>=3){
      for (let i=0;i<n;i++) for (let j=i+1;j<n;j++) for (let k=j+1;k<n;k++){
        let sum=0, need=(1<<i)|(1<<j)|(1<<k);
        for (let m=0;m<counts.length;m++) if ((m & need) === need) sum += counts[m];
        triples.push({i,j,k,count:sum});
      }
    }

    return { perElement: per, countsByMask: counts, singles, pairs, diffs, triples, total };
  }

  // ---------- Region logic ----------
  function prettyExpr(kind, idx){
    const id = (i) => state.sets[i]?.id || "?";
    if (kind==='single') return `${id(idx[0])}`;
    if (kind==='pair') return `${id(idx[0])} ∩ ${id(idx[1])}`;
    if (kind==='diff') return `${id(idx[0])} \\ ${id(idx[1])}`;
    if (kind==='triple') return `${id(idx[0])} ∩ ${id(idx[1])} ∩ ${id(idx[2])}`;
    if (kind==='outside') return `Outside all sets`;
    if (kind==='all') return `Union (all sets)`;
    return '—';
  }

  function countForHighlight(kind, idx, counts, total){
    if (!kind) return 0;
    const n = state.sets.length;
    if (kind==='outside') return counts[0];
    if (kind==='all') return total - counts[0];
    let sum=0;
    for (let m=0;m<counts.length;m++){
      if (kind==='single'){ if (m & (1<<idx[0])) sum += counts[m]; }
      else if (kind==='pair'){ const need=(1<<idx[0])|(1<<idx[1]); if ((m & need) === need) sum += counts[m]; }
      else if (kind==='diff'){ if ((m & (1<<idx[0])) && !(m & (1<<idx[1]))) sum += counts[m]; }
      else if (kind==='triple'){ const need=(1<<idx[0])|(1<<idx[1])|(1<<idx[2]); if ((m & need) === need) sum += counts[m]; }
    }
    return sum;
  }

  function elementInRegion(maskBits, kind, idx){
    if (kind==='outside') return maskBits === 0;
    if (kind==='all') return maskBits !== 0;
    if (kind==='single') return (maskBits & (1<<idx[0])) !== 0;
    if (kind==='pair') return (maskBits & (1<<idx[0])) && (maskBits & (1<<idx[1]));
    if (kind==='diff') return (maskBits & (1<<idx[0])) && !(maskBits & (1<<idx[1]));
    if (kind==='triple') return (maskBits & (1<<idx[0])) && (maskBits & (1<<idx[1])) && (maskBits & (1<<idx[2]));
    return false;
  }

  // ---------- Mask for strong highlight ----------
  function makeMask(kind, indices){
    if (!kind) return null;
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const mask = document.createElement('canvas');
    mask.width = canvas.width; mask.height = canvas.height;
    const m = mask.getContext('2d');
    m.setTransform(dpr,0,0,dpr,0,0);
    m.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
    m.fillStyle = "#000";
    const fillCircle = (i) => {
      const s = state.sets[i];
      m.beginPath(); m.arc(pxX(s.x), pxY(s.y), s.r*S(), 0, Math.PI*2); m.closePath(); m.fill();
    };

    if (kind === 'single'){
      fillCircle(indices[0]);
    } else if (kind === 'pair'){
      fillCircle(indices[0]);
      m.globalCompositeOperation = 'destination-in';
      fillCircle(indices[1]);
    } else if (kind === 'diff'){ // A\B
      fillCircle(indices[0]);
      m.globalCompositeOperation = 'destination-out';
      fillCircle(indices[1]);
    } else if (kind === 'triple'){
      fillCircle(indices[0]);
      m.globalCompositeOperation = 'destination-in';
      fillCircle(indices[1]);
      fillCircle(indices[2]);
    } else if (kind === 'outside'){
      m.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
      m.globalCompositeOperation = 'destination-out';
      for (let i=0;i<state.sets.length;i++){ fillCircle(i); }
    } else if (kind === 'all'){
      for (let i=0;i<state.sets.length;i++){ fillCircle(i); } // union
    }
    return mask;
  }

  // ---------- Drawing ----------
  function draw(){
    state.needsDraw = false;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // Universe
    ctx.save();
    ctx.fillStyle = "#0c1220";
    ctx.strokeStyle = "#223045";
    ctx.lineWidth = 1.5;
    roundRect(ctx, 8.5, 8.5, w-17, h-17, 12);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    // Sets (base)
    for (const s of state.sets){
      const cx = pxX(s.x), cy = pxY(s.y), r = s.r * S();

      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.closePath();
      ctx.fillStyle = hexToRgba(s.color, 0.17); ctx.fill();

      ctx.lineWidth = 2.0; ctx.strokeStyle = s.color; ctx.stroke();

      // Title badge
      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      const text = s.name;
      const tw = ctx.measureText(text).width + 12, th = 22;
      ctx.fillStyle = hexToRgba("#0d1320", 0.85);
      roundRect(ctx, cx - tw/2, cy - th/2, tw, th, 9); ctx.fill();
      ctx.fillStyle = "#cfe0ff"; ctx.fillText(text, cx, cy+0.5);
    }

    // Elements (base)
    const mem = memberships();
    for (let ei=0; ei<state.elements.length; ei++){
      const e = state.elements[ei];
      const ex = pxX(e.x), ey = pxY(e.y);
      const mask = mem.perElement[ei];
      const colors = [];
      for (let si=0; si<state.sets.length; si++) if (mask & (1<<si)) colors.push(state.sets[si].color);
      const stroke = colors.length ? mixColors(colors) : "#9fb2c7";

      ctx.beginPath(); ctx.arc(ex, ey, 6, 0, Math.PI*2); ctx.closePath();
      ctx.fillStyle = "#0d1320"; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = stroke; ctx.stroke();

      if (document.getElementById("showLabels").checked){
        const label = e.label;
        ctx.font = "500 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "left"; ctx.textBaseline = "middle";
        const padX = 9, tw = ctx.measureText(label).width + padX*2, th = 20;
        ctx.fillStyle = "rgba(10,16,28,0.9)";
        roundRect(ctx, ex + 10, ey - th/2, tw, th, 8); ctx.fill();
        ctx.strokeStyle = "#233040"; ctx.lineWidth = 1;
        roundRect(ctx, ex + 10, ey - th/2, tw, th, 8); ctx.stroke();
        ctx.fillStyle = "#d7e6ff"; ctx.fillText(label, ex + 10 + padX, ey+0.5);
      }
    }

    // Strong region highlight overlay + update explanation
    if (state.highlight){
      drawStrongHighlight(state.highlight, mem);
      updateExplain(state.highlight, mem);
    } else {
      clearHighlightChip();
      // Keep default explanation if no selection
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }

  function drawStrongHighlight(hl, mem){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const mask = makeMask(hl.kind, hl.indices);

    // 1) Dim everything
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,w,h);
    if (mask){
      ctx.globalCompositeOperation = 'destination-out';
      ctx.drawImage(mask, 0, 0, canvas.width, canvas.height, 0, 0, w, h);
    }
    ctx.restore();

    // 2) Colorize region + glow
    if (mask){
      ctx.save();
      ctx.drawImage(mask, 0, 0, canvas.width, canvas.height, 0, 0, w, h);
      ctx.globalCompositeOperation = 'source-in';
      ctx.fillStyle = 'rgba(255,213,74,0.38)'; // gold core
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.shadowColor = 'rgba(255,213,74,0.85)';
      ctx.shadowBlur = 22;
      ctx.globalAlpha = 0.6;
      ctx.drawImage(mask, 0, 0, canvas.width, canvas.height, 0, 0, w, h);
      ctx.restore();
    }

    // 3) Emphasize involved set boundaries
    const ids = hl.indices || [];
    if (hl.kind !== 'outside'){
      if (hl.kind === 'diff'){
        // A gets gold, B gets soft red
        const [a,b] = ids;
        if (Number.isInteger(a)) strokeSet(a, 'rgba(255,213,74,0.95)', 4.5);
        if (Number.isInteger(b)) strokeSet(b, 'rgba(255,107,107,0.95)', 4.0);
      } else {
        const color = ids.length ? mixColors(ids.map(i => state.sets[i].color)) : "#ffd54a";
        ids.forEach(i => strokeSet(i, hexToRgba(color, 0.95), 4.5));
      }
    }
    function strokeSet(i, color, width){
      const s = state.sets[i];
      if (!s) return;
      ctx.save();
      ctx.lineWidth = width;
      ctx.strokeStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 10;
      ctx.beginPath(); ctx.arc(pxX(s.x), pxY(s.y), s.r*S(), 0, Math.PI*2); ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    // 4) Halo elements inside region
    const per = mem.perElement;
    for (let ei=0; ei<state.elements.length; ei++){
      if (!elementInRegion(per[ei], hl.kind, hl.indices)) continue;
      const e = state.elements[ei];
      const ex = pxX(e.x), ey = pxY(e.y);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,213,74,0.85)';
      ctx.beginPath(); ctx.arc(ex, ey, 12, 0, Math.PI*2); ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // 5) Label chip on canvas
    const expr = prettyExpr(hl.kind, hl.indices);
    const count = countForHighlight(hl.kind, hl.indices, mem.countsByMask, mem.total);
    hlChip.style.display = 'block';
    hlChip.textContent = `${expr} — ${count} element${count===1?'':'s'}`;
  }

  function clearHighlightChip(){ hlChip.style.display = 'none'; }

  // ---------- Explanation panel (text response below canvas) ----------
  function updateExplain(hl, mem){
    const expr = prettyExpr(hl.kind, hl.indices);
    const count = countForHighlight(hl.kind, hl.indices, mem.countsByMask, mem.total);

    expExpr.textContent = expr;
    expCount.textContent = `(${count} element${count===1?'':'s'})`;

    // Build list of element labels in region
    const items = [];
    for (let i=0; i<state.elements.length; i++){
      if (elementInRegion(mem.perElement[i], hl.kind, hl.indices)){
        items.push(state.elements[i].label);
      }
    }
    expList.innerHTML = items.map(t => `<li>${t}</li>`).join("") || `<li><em>None</em></li>`;
    expElemsBlock.style.display = 'block';

    // Contextual text
    const name = (i) => state.sets[i]?.name || `Set ${i+1}`;
    const id = (i) => state.sets[i]?.id || `S${i+1}`;

    let desc = "";
    if (hl.kind === 'single'){
      desc = `Elements inside **${name(hl.indices[0])}** (${id(hl.indices[0])}). This includes any item located within that circle regardless of other sets.`;
    } else if (hl.kind === 'pair'){
      desc = `Elements common to both **${name(hl.indices[0])}** (${id(hl.indices[0])}) and **${name(hl.indices[1])}** (${id(hl.indices[1])}); i.e., the intersection **${id(hl.indices[0])} ∩ ${id(hl.indices[1])}**.`;
    } else if (hl.kind === 'diff'){
      desc = `Elements in **${name(hl.indices[0])}** (${id(hl.indices[0])}) but *not* in **${name(hl.indices[1])}** (${id(hl.indices[1])}); this is the set difference **${id(hl.indices[0])} \\ ${id(hl.indices[1])}**.`;
    } else if (hl.kind === 'triple'){
      desc = `Elements that belong to all three sets **${name(hl.indices[0])}**, **${name(hl.indices[1])}**, and **${name(hl.indices[2])}**; i.e., the triple intersection.`;
    } else if (hl.kind === 'outside'){
      const unionIds = state.sets.map((_,i)=>state.sets[i].id).join(" ∪ ");
      desc = `Elements **outside all sets**, i.e., in the complement **U \\ (${unionIds})**.`;
    } else if (hl.kind === 'all'){
      const unionNames = state.sets.map(s=>`${s.name} (${s.id})`).join(", ");
      desc = `Elements in the **union of all sets** (${unionNames}).`;
    }

    // Geology reminder
    desc += ` In geology terms, sets reflect rock categories or processes; a label is a member if it lies inside that set's circle.`;

    expText.innerHTML = desc;
  }

  // ---------- UI builders ----------
  function rebuildSetChips(){
    const setsChipsEl = document.getElementById("setsChips");
    setsChipsEl.innerHTML = "";
    state.sets.forEach((s) => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.innerHTML = `<span class="dot" style="background:${s.color}"></span><strong>${s.name}</strong> <small>(${s.id})</small>`;
      chip.title = `Set ${s.name} [${s.id}]`;
      setsChipsEl.appendChild(chip);
    });

    // Header for membership table
    const theadRowEl = document.getElementById("theadRow");
    while (theadRowEl.children.length > 1) theadRowEl.removeChild(theadRowEl.lastChild);
    state.sets.forEach(s => {
      const th = document.createElement("th");
      th.textContent = s.name;
      theadRowEl.appendChild(th);
    });
  }

  function updateRegionsAndTable(){
    const { countsByMask, singles, pairs, diffs, triples, perElement, total } = memberships();
    const n = state.sets.length;
    const outside = countsByMask[0];

    const regionsEl = document.getElementById("regions");
    regionsEl.innerHTML = `<h2>Regions &amp; Intersections</h2>`;

    const addSubhead = (text) => {
      const row = document.createElement("div");
      row.className = "row subhead";
      row.textContent = text;
      regionsEl.appendChild(row);
    };

    const addRow = (lhsHtml, k, kind=null, indices=[]) => {
      const row = document.createElement("div");
      row.className = "row";
      row.innerHTML = `<div class="lhs">${lhsHtml}</div><div class="k">${k}</div>`;
      if (kind){
        row.dataset.kind = kind;
        row.dataset.indices = indices.join(",");
        row.title = "Click to highlight this region";
        row.addEventListener("click", () => {
          const same = state.highlight &&
                       state.highlight.kind === kind &&
                       JSON.stringify(state.highlight.indices) === JSON.stringify(indices);
          state.highlight = same ? null : {kind, indices};
          // Row selection visual
          document.querySelectorAll(".summary .row").forEach(el => el.classList.remove("selected"));
          if (!same) row.classList.add("selected");
          if (same) { clearHighlightChip(); }
          requestDraw();
        });
      } else { row.style.cursor = "default"; }
      // Maintain selected styling on rebuild
      if (state.highlight && state.highlight.kind === kind &&
          JSON.stringify(state.highlight.indices) === JSON.stringify(indices)){
        row.classList.add("selected");
      }
      regionsEl.appendChild(row);
    };

    // Totals
    addSubhead("Totals");
    addRow(`<span class="badge">Total elements</span>`, total, "all", []);
    addRow(`<span class="badge">Outside all sets</span>`, outside, "outside", []);

    // Singles
    addSubhead("Singles (Inside A)");
    singles.forEach((cnt, i) => {
      const s = state.sets[i];
      addRow(`<span class="badge"><span class="dot" style="background:${s.color}"></span>${s.name}</span>`, cnt, "single", [i]);
    });

    // Pairs (intersections)
    if (pairs.length){
      addSubhead("Pairs (A ∩ B)");
      pairs.forEach(({i,j,count}) => {
        const a = state.sets[i], b = state.sets[j];
        const dot = `<span class="dot" style="background:${mixColors([a.color,b.color])}"></span>`;
        addRow(`${dot}<code>${a.id} ∩ ${b.id}</code>`, count, "pair", [i,j]);
      });
    }

    // Differences (A \ B)
    if (diffs.length){
      addSubhead("Differences (A \\ B)");
      diffs.forEach(({i,j,count}) => {
        const a = state.sets[i], b = state.sets[j];
        addRow(
          `<span class="dot" style="background:${a.color}"></span><code>${a.id} \\ ${b.id}</code>`,
          count, "diff", [i,j]
        );
      });
    }

    // Triples
    if (triples.length){
      addSubhead("Triples (A ∩ B ∩ C)");
      triples.forEach(({i,j,k,count}) => {
        const a = state.sets[i], b = state.sets[j], c = state.sets[k];
        const dot = `<span class="dot" style="background:${mixColors([a.color,b.color,c.color])}"></span>`;
        addRow(`${dot}<code>${a.id} ∩ ${b.id} ∩ ${c.id}</code>`, count, "triple", [i,j,k]);
      });
    }

    // Elements table
    const tbodyEl = document.getElementById("tbody");
    tbodyEl.innerHTML = "";
    state.elements.forEach((e, idx) => {
      const tr = document.createElement("tr");
      const name = document.createElement("td");
      name.textContent = e.label;
      tr.appendChild(name);

      for (let si=0; si<n; si++){
        const td = document.createElement("td");
        td.className = "k";
        td.textContent = (perElement[idx] & (1<<si)) ? "✓" : "—";
        tr.appendChild(td);
      }
      tbodyEl.appendChild(tr);
    });
  }

  // ---------- Interaction ----------
  function onPointerDown(ev){
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
    const pick = pickAt(x,y);
    if (!pick) return;

    if (pick.type === "set" && document.getElementById("lockSets").checked) return;
    if (pick.type === "element" && document.getElementById("lockElements").checked) return;

    state.drag = {type: pick.type, index: pick.index, dx:0, dy:0};
    if (pick.type === "set"){
      const s = state.sets[pick.index];
      state.drag.dx = pxX(s.x) - x;
      state.drag.dy = pxY(s.y) - y;
    } else {
      const e = state.elements[pick.index];
      state.drag.dx = pxX(e.x) - x;
      state.drag.dy = pxY(e.y) - y;
    }
    ev.preventDefault();
  }

  function onPointerMove(ev){
    if (!state.drag) return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
    const nx = nX(x + state.drag.dx);
    const ny = nY(y + state.drag.dy);

    if (state.drag.type === "set"){
      const s = state.sets[state.drag.index];
      const rpx = s.r * S();
      const minX = rpx / canvas.clientWidth;
      const maxX = 1 - minX;
      const minY = rpx / canvas.clientHeight;
      const maxY = 1 - minY;
      s.x = clamp(nx, minX, maxX);
      s.y = clamp(ny, minY, maxY);
    } else {
      const e = state.elements[state.drag.index];
      e.x = clamp(nx, 0, 1);
      e.y = clamp(ny, 0, 1);
    }
    requestDraw();
    ev.preventDefault();
  }

  function onPointerUp(){ state.drag = null; }

  function onWheel(ev){
    if (document.getElementById("lockSets").checked) return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
    const pick = pickAt(x,y);
    if (!pick || pick.type !== "set") return;

    const s = state.sets[pick.index];
    const factor = (ev.deltaY < 0) ? 1.05 : 0.95;
    s.r = clamp(s.r * factor, 0.06, 0.5);

    // Keep circle fully inside
    const rpx = s.r * S();
    const minX = rpx / canvas.clientWidth;
    const maxX = 1 - minX;
    const minY = rpx / canvas.clientHeight;
    const maxY = 1 - minY;
    s.x = clamp(s.x, minX, maxX);
    s.y = clamp(s.y, minY, maxY);

    requestDraw();
    ev.preventDefault();
  }

  // Keyboard: Esc to clear highlight
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && state.highlight){
      state.highlight = null;
      document.querySelectorAll(".summary .row").forEach(el => el.classList.remove("selected"));
      clearHighlightChip();
      // Reset text panel to default
      expExpr.textContent = "—";
      expCount.textContent = "(0 elements)";
      expText.innerHTML = "Click a region in the right panel to see a description and the elements that belong to it. In this geology context, sets represent rock categories; an item belongs to a set if its label lies inside that circle.";
      expElemsBlock.style.display = 'none';
      requestDraw();
    }
  });

  // ---------- Save/Load/Reset ----------
  function exportJSON(){
    const data = { universe: state.universe, sets: state.sets, elements: state.elements };
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "geology_sets.json";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function loadJSON(obj){
    if (!obj || !obj.universe || !obj.sets || !obj.elements) return;
    state.universe = obj.universe;
    state.sets = obj.sets;
    state.elements = obj.elements;
    document.getElementById("uName").textContent = state.universe.name || "Universe (U)";
    rebuildSetChips();
    requestDraw();
    updateRegionsAndTable();
  }

  async function resetToDefault(){
    const res = await fetch("/api/default");
    const data = await res.json();
    loadJSON(data);
  }

  // ---------- Animation loop ----------
  function requestDraw(){ state.needsDraw = true; }
  function loop(){
    if (state.needsDraw){
      draw();
      updateRegionsAndTable();
    }
    requestAnimationFrame(loop);
  }

  // ---------- Events ----------
  window.addEventListener("resize", resizeCanvas);
  canvas.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove);
  window.addEventListener("pointerup", onPointerUp);
  canvas.addEventListener("wheel", onWheel, {passive:false});

  document.getElementById("btnSave").addEventListener("click", exportJSON);
  document.getElementById("btnReset").addEventListener("click", resetToDefault);
  document.getElementById("fileLoad").addEventListener("change", (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      try { loadJSON(JSON.parse(String(reader.result))); }
      catch(err){ alert("Invalid JSON file"); }
    };
    reader.readAsText(f);
  });
  document.getElementById("showLabels").addEventListener("change", requestDraw);

  // ---------- Boot ----------
  (async function boot(){
    resizeCanvas();
    await resetToDefault();
    loop();
  })();
})();
</script>
</body>
</html>
