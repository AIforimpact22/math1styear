{% extends "index.html" %}
{% block page_title %}Function Basics Game (Simple){% endblock %}

{% block controls %}
<div class="controls" aria-label="Function game controls">
  <button id="btnNew" class="btn">New Puzzle</button>
  <button id="btnReset" class="btn">Reset Choices</button>
  <button id="btnReveal" class="btn">Reveal Solution</button>
</div>
{% endblock %}

{% block content %}
<section class="canvas-card" aria-label="Function mapping table">
  <style>
    .simple-board{ padding:12px; }
    .simple-board table{ width:100%; border-collapse:collapse; border:1px solid #233040; border-radius:12px; overflow:hidden; }
    .simple-board thead th{ background:#0d1320; color:#9fb2c7; padding:8px; text-align:left; font-size:12px; }
    .simple-board tbody td{ padding:8px; border-bottom:1px solid #1e2a3a; }
    .simple-board tr:last-child td{ border-bottom:none; }
    .arrow{ text-align:center; color:#9fb2c7; width:60px; }
    select.mapping{
      width:100%; padding:6px 8px; border-radius:8px; border:1px solid #233040; background:#0f141c; color:#e6f0ff;
    }
    select.mapping:focus{ outline:2px solid #7aa2ff; border-color:#2b3a4f; }
    .dup{ border-color:#8a2a2a !important; background:#2a1515 !important; }
    .good{ color:#34d399; font-weight:700; }
    .bad{ color:#ef4444; font-weight:700; }
  </style>

  <div class="simple-board">
    <table>
      <thead>
        <tr>
          <th style="width:40%">Rock Sample (Domain D)</th>
          <th class="arrow">f</th>
          <th style="width:48%">Mineral Signature (Codomain E)</th>
          <th style="width:12%">✓</th>
        </tr>
      </thead>
      <tbody id="mapBody">
        <!-- rows are injected here -->
      </tbody>
    </table>
    <div class="board-legend" style="display:flex; gap:10px; align-items:center; padding-top:8px;">
      <span class="pill">Goal: Make the mapping a <strong>bijection</strong> (1‑1 and onto) → then it is invertible.</span>
    </div>
  </div>
</section>

<aside>
  <div>
    <h2>Function (Geology)</h2>
    <div class="sets-top">
      <div class="badge">Universe: <strong id="uName">…</strong></div>

      <div class="score" aria-live="polite">
        <span id="scoreText">Score: 0/0 (0%)</span>
        <div class="bar"><div id="scoreFill" class="fill"></div></div>
      </div>

      <div class="tips" style="margin-top:6px;">
        <div class="pill" style="margin-bottom:6px;">Tip</div>
        <div>Pick exactly one signature for each sample (function).</div>
        <div>No two samples should share a signature (injective).</div>
        <div>Every signature is used at least once (surjective).</div>
      </div>
    </div>
  </div>

  <div>
    <h2>Status</h2>
    <div id="props" class="summary" style="gap:6px;">
      <!-- Filled by JS -->
    </div>
  </div>

  <div>
    <h2>Definitions (quick)</h2>
    <ul class="help-list">
      <li><strong>Függvény</strong> (Function): minden D‑beli elemhez pontosan egy E‑beli elem tartozik.</li>
      <li><strong>Injektív</strong> (1‑1): különböző D‑elemek különböző E‑elemekhez mennek.</li>
      <li><strong>Szürjektív</strong> (Onto): minden E‑elemhez jut legalább egy D‑elem.</li>
      <li><strong>Bijekció</strong>: egyszerre injektív és szürjektív ⇒ <em>invertálható</em>.</li>
      <li><strong>Ekvivalens halmazok</strong>: létezik köztük 1‑1 hozzárendelés (bijekció).</li>
    </ul>
  </div>
</aside>

<section class="explain-card" aria-live="polite" aria-label="Explanation">
  <div class="explain-head">
    <span class="badge">Explanation</span>
  </div>
  <div class="explain-body" id="explain">
    Domain D = rock samples (Basalt, Granite, Limestone, Gneiss).  
    Codomain E = mineral signatures (Olivine‑rich, Feldspar‑dominant, Calcite‑dominant, Quartz‑rich).  
    Choose one signature for each sample. When your mapping is <strong>bijective</strong>, it’s invertible, so we can define the inverse \(f^{-1}\) that maps each signature back to its unique sample.
  </div>
</section>
{% endblock %}

{% block scripts %}
<script>
(() => {
  // ------- State -------
  const state = {
    universeName: "",
    domain: [],
    codomain: [],
    solution: {},     // {S1:"C1",...}
    mapping: {},      // {S1:"C2",...} (user choices; "" means none)
  };

  // ------- Elements -------
  const uName = document.getElementById("uName");
  const mapBody = document.getElementById("mapBody");
  const props = document.getElementById("props");
  const scoreText = document.getElementById("scoreText");
  const scoreFill = document.getElementById("scoreFill");

  // ------- Helpers -------
  const toMap = (pairs) => Object.fromEntries(pairs);
  const unique = (arr) => Array.from(new Set(arr));

  function isFunction(){
    // every domain item has exactly one non-empty image
    return state.domain.every(d => state.mapping[d.id] && state.mapping[d.id] !== "");
  }
  function isInjective(){
    const images = state.domain.map(d => state.mapping[d.id]).filter(Boolean);
    return images.length === unique(images).length;
  }
  function isSurjective(){
    const images = new Set(state.domain.map(d => state.mapping[d.id]).filter(Boolean));
    return state.codomain.every(c => images.has(c.id));
  }
  const isBijection = () => isFunction() && isInjective() && isSurjective();

  function correctCount(){
    let ok = 0;
    for (const d of state.domain){
      if (state.mapping[d.id] && state.mapping[d.id] === state.solution[d.id]) ok++;
    }
    return ok;
  }

  function updateScore(){
    const total = state.domain.length;
    const ok = correctCount();
    const pct = total ? Math.round(100 * ok / total) : 0;
    scoreText.textContent = `Score: ${ok}/${total} (${pct}%)`;
    scoreFill.style.width = `${pct}%`;
  }

  function updateProps(){
    const badge = (good, text) => {
      const cls = good ? "row selected" : "row";
      const tick = good ? `<span class="ok">✓</span>` : `<span class="bad">✗</span>`;
      const el = document.createElement("div");
      el.className = cls;
      el.innerHTML = `<div class="lhs">${tick} ${text}</div>`;
      return el;
    };
    props.innerHTML = "";
    props.appendChild(badge(isFunction(),  "Function: each sample has exactly one signature"));
    props.appendChild(badge(isInjective(),"Injective (1–1): no two samples share a signature"));
    props.appendChild(badge(isSurjective(),"Surjective (onto): every signature is used"));
    props.appendChild(badge(isBijection(),"Bijection ⇒ invertible"));
  }

  function markDuplicates(){
    // highlight selects that collide on same codomain (violates injective)
    const vals = {};
    document.querySelectorAll("select.mapping").forEach(sel => {
      const v = sel.value;
      sel.classList.remove("dup");
      if (!v) return;
      vals[v] = (vals[v] || []);
      vals[v].push(sel);
    });
    Object.values(vals).forEach(list => {
      if (list.length > 1) list.forEach(sel => sel.classList.add("dup"));
    });
  }

  function rebuildTable(){
    mapBody.innerHTML = "";
    state.domain.forEach((d, idx) => {
      const tr = document.createElement("tr");

      const tdL = document.createElement("td");
      tdL.textContent = d.label;
      tr.appendChild(tdL);

      const tdArrow = document.createElement("td");
      tdArrow.className = "arrow";
      tdArrow.textContent = "→";
      tr.appendChild(tdArrow);

      const tdR = document.createElement("td");
      const sel = document.createElement("select");
      sel.className = "mapping";
      sel.id = `sel_${d.id}`;
      // options
      const opt0 = document.createElement("option");
      opt0.value = ""; opt0.textContent = "— choose —";
      sel.appendChild(opt0);
      state.codomain.forEach(c => {
        const o = document.createElement("option");
        o.value = c.id; o.textContent = c.label;
        sel.appendChild(o);
      });
      // initial value
      sel.value = state.mapping[d.id] || "";
      sel.addEventListener("change", () => {
        state.mapping[d.id] = sel.value;
        // live updates
        tdOk.innerHTML = (sel.value && sel.value === state.solution[d.id]) ? `<span class="good">✓</span>` : "—";
        markDuplicates();
        updateProps();
        updateScore();
      });
      tdR.appendChild(sel);
      tr.appendChild(tdR);

      const tdOk = document.createElement("td");
      tdOk.className = "k";
      tdOk.innerHTML = (sel.value && sel.value === state.solution[d.id]) ? `<span class="good">✓</span>` : "—";
      tr.appendChild(tdOk);

      mapBody.appendChild(tr);
    });

    markDuplicates();
  }

  // ------- Controls -------
  async function loadPuzzle(){
    const res = await fetch("/function/api/puzzle");
    const data = await res.json();
    state.universeName = data.universe?.name || "Functions in Geology (D → E)";
    state.domain = data.domain || [];
    state.codomain = data.codomain || [];
    state.solution = toMap(data.solution_pairs || []);
    state.mapping = {};
    (data.initial_pairs || []).forEach(([d, c]) => { state.mapping[d] = c || ""; });

    uName.textContent = state.universeName;
    rebuildTable();
    updateProps();
    updateScore();
  }

  function resetChoices(){
    for (const d of state.domain) state.mapping[d.id] = "";
    document.querySelectorAll("select.mapping").forEach(sel => sel.value = "");
    rebuildTable();
    updateProps();
    updateScore();
  }

  function revealSolution(){
    for (const d of state.domain) {
      const v = state.solution[d.id] || "";
      state.mapping[d.id] = v;
      const sel = document.getElementById(`sel_${d.id}`);
      if (sel) sel.value = v;
    }
    rebuildTable();
    updateProps();
    updateScore();
  }

  document.getElementById("btnNew").addEventListener("click", loadPuzzle);
  document.getElementById("btnReset").addEventListener("click", resetChoices);
  document.getElementById("btnReveal").addEventListener("click", revealSolution);

  // ------- Boot -------
  (async function boot(){
    await loadPuzzle();
  })();
})();
</script>
{% endblock %}
