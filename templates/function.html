{% extends "index.html" %}
{% block page_title %}Function Fundamentals Game{% endblock %}

{% block controls %}
<div class="controls" aria-label="Function game controls">
  <button id="btnNewFunc" class="btn">New Function Puzzle</button>
  <button id="btnClearMap" class="btn">Clear All Links</button>
  <button id="btnInvert" class="btn">Invert (if bijection)</button>
  <label class="switch btn"><input id="lockLinks" type="checkbox" /> Lock Links</label>
</div>
{% endblock %}

{% block content %}
<section class="canvas-card" aria-label="Function mapping board">
  <style>
    .board{ position:relative; display:flex; gap:24px; padding:12px; min-height: 52vh; }
    .col{ flex:1; }
    .col h3{ margin:6px 0 8px; color:#cbd7ea; font-size:14px; }
    .slots{ list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:8px; }
    .slot{
      position:relative; display:flex; align-items:center; justify-content:space-between; gap:8px;
      background:#0f141c; border:1px solid #233040; padding:8px 10px; border-radius:10px;
      cursor:pointer; user-select:none;
    }
    .slot:hover{ border-color:#2b3a4f; background:#0c1219; }
    .slot.selected{ outline:2px solid #7aa2ff; }
    .slot .tag{ font-size:12px; color:#9fb2c7; }
    .slot .name{ font-weight:600; color:#e3ecff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .slot .mapto{
      font-size:11px; color:#a7b8cc; border:1px solid #273349; background:#0e1523; border-radius:999px; padding:2px 6px;
    }

    .board svg#mapSvg{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }
    .link{ fill:none; stroke:#7aa2ff; stroke-width:2.5px; opacity:0.95; }
    .link.collide{ stroke:#ef8a8a; }
    .link.good{ stroke:#34d399; }
    .link.temp{ stroke:#a1c3ff; stroke-dasharray:6 6; opacity:0.9; }

    .board-legend{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap; padding:8px 12px; border-top:1px solid #233040;
      background:rgba(18,24,33,0.6);
    }
    .legend-chip{ display:inline-flex; align-items:center; gap:6px; font-size:12px; color:#a7b8cc; }
    .legend-dot{ width:12px; height:3px; background:#7aa2ff; display:inline-block; }
    .legend-dot.collide{ background:#ef8a8a; }
    .legend-dot.good{ background:#34d399; }

    .sets-top .badge{ display:inline-flex; gap:6px; align-items:center; padding:4px 8px; border-radius:999px;
      background:#0d1320; border:1px solid #263243; font-size:12px; color:#9fb2c7; width:fit-content; }

    .props{ display:flex; flex-wrap:wrap; gap:6px; }
    .prop-chip{
      display:inline-flex; align-items:center; gap:6px; padding:4px 8px;
      border-radius:999px; background:#0e1523; border:1px solid #223045; color:#cfe0ff; font-size:12px;
    }
    .prop-chip.good{ border-color:#1f6f4f; background:#11281f; color:#a8f0c4; }
    .prop-chip.bad{ border-color:#5a2831; background:#2a1115; color:#ffb4bf; }

    .diagnostics{ display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
    .diag{ font-size:12px; color:#a9b8cc; border:1px dashed #33455e; padding:4px 8px; border-radius:8px; }
    .diag strong{ color:#e5f0ff; }

    .rule-card{ background: var(--card); border:1px solid #233040; border-radius:14px; padding:12px; }
    .rule-card h3{ margin:0 0 6px; font-size:14px; color:#cbd7ea; }
    .rule-card ul{ margin:6px 0 0 18px; color:#d7e6ff; }
    .rule-card code{ background:#0d1320; border:1px solid #263243; padding:2px 6px; border-radius:6px; color:#a9c3ff; }
  </style>

  <div class="board" id="board">
    <svg id="mapSvg" aria-hidden="true"></svg>

    <div class="col">
      <h3 id="domTitle">Domain D</h3>
      <ul id="domainList" class="slots"></ul>
    </div>

    <div class="col">
      <h3 id="codTitle">Codomain E</h3>
      <ul id="codomainList" class="slots"></ul>
    </div>
  </div>

  <div class="board-legend">
    <span class="legend-chip"><span class="legend-dot"></span> link</span>
    <span class="legend-chip"><span class="legend-dot collide"></span> collision (not injective)</span>
    <span class="legend-chip"><span class="legend-dot good"></span> bijection link</span>
  </div>
</section>

<aside>
  <div>
    <h2>Function Lab (Geology)</h2>
    <div class="sets-top">
      <div class="badge">Universe: <strong id="uName">…</strong></div>

      <div class="score" aria-live="polite">
        <span id="scoreText">Score: 0/0 (0%)</span>
        <div class="bar"><div id="scoreFill" class="fill"></div></div>
      </div>

      <div class="tips">
        <div class="pill" style="margin:6px 0;">Tip</div>
        <div>Click a sample (left), then a signature (right) to connect — or <strong>drag</strong> from left to right.</div>
        <div><strong>Alt+Click</strong> a left item to clear its link. Invert only when mapping is a bijection.</div>
      </div>
    </div>
  </div>

  <div>
    <h2>Status & Properties</h2>
    <div class="props" id="propChips"></div>
    <div class="diagnostics" id="diagnostics"></div>
  </div>

  <div class="rule-card">
    <h3>Rules of a Function — geology context</h3>
    <ul class="help-list">
      <li><strong>Függvény</strong> (function): minden <em>D</em>-beli elemhez <u>pontosan egy</u> <em>E</em>-beli elemet rendelünk.<br>
          (Each rock sample has exactly one mineral‑signature outcome.)</li>
      <li><strong>Injektív</strong> (1‑1): különböző mintákhoz különböző signatúrák tartoznak.<br>
          (No two different samples share the same signature.)</li>
      <li><strong>Szürjektív</strong> (onto): minden signatúra szerepel legalább egyszer.<br>
          (Every signature in E is used by some sample.)</li>
      <li><strong>Bijekció</strong> (ekvivalencia D ↔ E): injektív és szürjektív egyszerre ⇒ <strong>invertálható</strong>, azaz létezik
          <code>g = f^{-1}</code> úgy, hogy <code>g(y)=x</code> ha <code>f(x)=y</code>.</li>
      <li><em>Megjegyzés</em>: ha <code>|D|=|E|</code> és végesek, akkor injektív ⇔ szürjektív ⇔ bijekció.</li>
    </ul>
  </div>

  <div class="rule-card" style="margin-top:10px;">
    <h3>Countability (megszámlálhatóság)</h3>
    <div style="margin-bottom:8px;">
      <label>n: <input id="nRange" type="range" min="0" max="20" value="0"></label>
      <span class="pill">n = <strong id="nVal">0</strong></span>
      <span class="pill">f(n)=n+1 ⇒ <strong id="fVal">1</strong></span>
      <span class="pill">g(n)=2n ⇒ <strong id="gVal">0</strong></span>
      <span class="pill">h(n)=2n+1 ⇒ <strong id="hVal">1</strong></span>
    </div>
    <ul class="help-list">
      <li><code>f(n)=n+1</code>, <code>g(n)=2n</code>, <code>h(n)=2n+1</code> mind 1‑1 megfeleltetést adnak <code>ℕ</code> és saját képeik között
          (pl. párosak, páratlanok) ⇒ ekvivalens, megszámlálható halmazok.</li>
      <li>Inverzek: <code>f^{-1}(n+1)=n</code>, <code>g^{-1}(2n)=n</code>, <code>h^{-1}(2n+1)=n</code>.</li>
    </ul>
  </div>
</aside>
{% endblock %}

{% block scripts %}
<script>
(() => {
  // -------------------- State --------------------
  const state = {
    universeName: "",
    domainName: "Domain D",
    codomainName: "Codomain E",
    domain: [],     // [{id,label}]
    codomain: [],   // [{id,label}]
    mapping: {},    // f: D -> E, e.g., { S1: "C3" }
    solution: [],   // [["S1","C1"], ...]
    view: "D2E",    // "D2E" or "E2D"
    lockLinks: false,

    // dragging (for drag-to-connect)
    drag: null,     // { leftId, pathEl }
  };

  // -------------------- DOM refs --------------------
  const uName = document.getElementById("uName");
  const domList = document.getElementById("domainList");
  const codList = document.getElementById("codomainList");
  const domTitle = document.getElementById("domTitle");
  const codTitle = document.getElementById("codTitle");
  const board = document.getElementById("board");
  const svg = document.getElementById("mapSvg");

  const propChips = document.getElementById("propChips");
  const diags = document.getElementById("diagnostics");
  const scoreText = document.getElementById("scoreText");
  const scoreFill = document.getElementById("scoreFill");

  const nRange = document.getElementById("nRange");
  const nVal = document.getElementById("nVal");
  const fVal = document.getElementById("fVal");
  const gVal = document.getElementById("gVal");
  const hVal = document.getElementById("hVal");

  // -------------------- Fetch puzzle --------------------
  async function loadPuzzle() {
    const res = await fetch(`/function/api/puzzle?seed=${Date.now()}`);
    const data = await res.json();

    state.universeName = data.universe?.name || "Functions in Geology (D → E)";
    state.domainName = data.universe?.domain_name || "Domain D";
    state.codomainName = data.universe?.codomain_name || "Codomain E";
    state.domain = data.domain || [];
    state.codomain = data.codomain || [];
    state.solution = data.solution_pairs || [];

    // start with intentionally wrong mapping
    state.mapping = {};
    (data.initial_pairs || []).forEach(([d, c]) => { state.mapping[d] = c; });

    state.view = "D2E";
    uName.textContent = state.universeName;

    buildColumns();
    drawLinks();
    updateAll();
  }

  // -------------------- Build columns --------------------
  function buildColumns() {
    domTitle.textContent = state.view === "D2E" ? state.domainName : `${state.codomainName} (as domain for g)`;
    codTitle.textContent = state.view === "D2E" ? state.codomainName : `Back to ${state.domainName}`;

    domList.innerHTML = "";
    codList.innerHTML = "";

    const leftItems = (state.view === "D2E") ? state.domain : state.codomain;
    const rightItems = (state.view === "D2E") ? state.codomain : state.domain;

    leftItems.forEach(item => {
      const li = document.createElement("li");
      li.className = "slot";
      li.dataset.id = item.id;
      li.innerHTML = `
        <span class="tag">${state.view==="D2E" ? "D" : "E"}</span>
        <span class="name">${item.label}</span>
        <span class="mapto" id="mapto_${item.id}">—</span>
      `;

      // Click selection (left), Alt+Click clears
      li.addEventListener("click", (ev) => {
        if (state.lockLinks) return;
        if (ev.altKey) { clearLinkForLeft(item.id); return; }
        selectLeft(li);
      });

      // Drag from left to right
      li.addEventListener("pointerdown", (ev) => {
        if (state.lockLinks) return;
        startDrag(item.id, ev);
      });

      domList.appendChild(li);
    });

    rightItems.forEach(item => {
      const li = document.createElement("li");
      li.className = "slot";
      li.dataset.id = item.id;
      li.innerHTML = `
        <span class="name">${item.label}</span>
        <span class="tag">${state.view==="D2E" ? "E" : "D"}</span>
      `;

      // Click right to connect from the currently selected left
      li.addEventListener("click", () => {
        if (state.lockLinks) return;
        const sel = domList.querySelector(".slot.selected");
        if (!sel) return;
        connect(sel.dataset.id, item.id);
        sel.classList.remove("selected");
      });

      codList.appendChild(li);
    });

    refreshMaptoBadges();
  }

  // Show the current mapping in small badges on the left column
  function refreshMaptoBadges(){
    const leftItems = (state.view === "D2E") ? state.domain : state.codomain;
    const rightItems = (state.view === "D2E") ? state.codomain : state.domain;
    const rightById = Object.fromEntries(rightItems.map(it => [it.id, it]));

    if (state.view === "D2E"){
      leftItems.forEach(it => {
        const s = document.getElementById(`mapto_${it.id}`);
        const tgt = state.mapping[it.id];
        s.textContent = tgt ? (rightById[tgt]?.label || tgt) : "—";
      });
    } else {
      // inverse view: show inverse map y->x
      const inv = invertMap(state.mapping);
      leftItems.forEach(it => {
        const s = document.getElementById(`mapto_${it.id}`);
        const tgt = inv[it.id];
        s.textContent = tgt ? (rightById[tgt]?.label || tgt) : "—";
      });
    }
  }

  // -------------------- Selection (click) --------------------
  function selectLeft(li){
    domList.querySelectorAll(".slot.selected").forEach(el => el.classList.remove("selected"));
    li.classList.add("selected");
  }

  // -------------------- Drag handling --------------------
  function startDrag(leftId, ev){
    // ensure leftId valid
    state.drag = { leftId, pathEl: makeTempPath() };
    updateTempPath(ev);
    window.addEventListener("pointermove", onDragMove);
    window.addEventListener("pointerup", onDragEnd, { once: true });
  }

  function onDragMove(ev){
    if (!state.drag) return;
    updateTempPath(ev);
  }

  function onDragEnd(ev){
    if (!state.drag) return;
    const endEl = document.elementFromPoint(ev.clientX, ev.clientY);
    const rightLi = endEl ? endEl.closest && endEl.closest("#codomainList .slot") : null;
    if (rightLi && !state.lockLinks){
      connect(state.drag.leftId, rightLi.dataset.id);
    }
    // cleanup
    if (state.drag.pathEl && state.drag.pathEl.parentNode) state.drag.pathEl.parentNode.removeChild(state.drag.pathEl);
    state.drag = null;
    window.removeEventListener("pointermove", onDragMove);
  }

  function makeTempPath(){
    const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
    p.setAttribute("class", "link temp");
    svg.appendChild(p);
    return p;
  }

  function updateTempPath(ev){
    const leftEl = domList.querySelector(`.slot[data-id="${state.drag.leftId}"]`);
    if (!leftEl || !state.drag.pathEl) return;
    const boardRect = board.getBoundingClientRect();
    const a = leftEl.getBoundingClientRect();

    const x1 = (a.right - boardRect.left);
    const y1 = (a.top + a.height/2) - boardRect.top;
    const x2 = ev.clientX - boardRect.left;
    const y2 = ev.clientY - boardRect.top;

    const dx = Math.max(60, Math.abs(x2 - x1) * 0.4);
    const d = `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`;
    state.drag.pathEl.setAttribute("d", d);
  }

  // -------------------- Connect / Clear --------------------
  function connect(leftId, rightId){
    if (state.view === "D2E"){
      state.mapping[leftId] = rightId;
    } else {
      // E2D view: connect y -> x means set f(x)=y
      const y = leftId, x = rightId;
      state.mapping[x] = y;
    }
    drawLinks();
    refreshMaptoBadges();
    updateAll();
  }

  function clearLinkForLeft(leftId){
    if (state.view === "D2E"){
      delete state.mapping[leftId];
    } else {
      // Inverse view: clearing y->x means remove f(x)=y
      const inv = invertMap(state.mapping);
      const x = inv[leftId];
      if (x) delete state.mapping[x];
    }
    drawLinks();
    refreshMaptoBadges();
    updateAll();
  }

  function invertMap(map){
    const inv = {};
    Object.entries(map).forEach(([x,y]) => { inv[y] = x; });
    return inv;
  }

  // -------------------- Draw SVG links --------------------
  function drawLinks(){
    // Clear
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    const leftList = domList.querySelectorAll(".slot");
    const rightList = codList.querySelectorAll(".slot");
    if (!leftList.length || !rightList.length) return;

    const L = {}; const R = {};
    leftList.forEach(li => L[li.dataset.id] = li);
    rightList.forEach(li => R[li.dataset.id] = li);

    const usage = {};
    const pairs = [];
    if (state.view === "D2E"){
      for (const [d,c] of Object.entries(state.mapping)){
        if (!L[d] || !R[c]) continue;
        usage[c] = (usage[c]||0)+1;
        pairs.push([d,c]);
      }
    } else {
      // inverse view draws y->x
      for (const [x,y] of Object.entries(state.mapping)){
        if (!L[y] || !R[x]) continue;
        usage[x] = (usage[x]||0)+1;
        pairs.push([y,x]);
      }
    }

    const rectAll = board.getBoundingClientRect();
    const pathFor = (fromEl, toEl) => {
      const a = fromEl.getBoundingClientRect();
      const b = toEl.getBoundingClientRect();
      const x1 = (a.right - rectAll.left);
      const y1 = (a.top + a.height/2) - rectAll.top;
      const x2 = (b.left - rectAll.left);
      const y2 = (b.top + b.height/2) - rectAll.top;
      const dx = Math.max(60, Math.abs(x2 - x1) * 0.4);
      return `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`;
    };

    pairs.forEach(([lid, rid]) => {
      const fromEl = L[lid];
      const toEl = R[rid];
      const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
      p.setAttribute("class", "link");
      p.setAttribute("d", pathFor(fromEl, toEl));

      // collision coloring (not injective)
      const target = rid; // on right side
      if (usage[target] > 1) p.classList.add("collide");

      // green if full bijection
      if (isBijection()) p.classList.add("good");

      svg.appendChild(p);
    });
  }

  // -------------------- Properties / Diagnostics / Score --------------------
  function currentLeftItems(){ return (state.view === "D2E") ? state.domain : state.codomain; }
  function currentRightItems(){ return (state.view === "D2E") ? state.codomain : state.domain; }

  function currentLeftToRight(){
    if (state.view === "D2E") return {...state.mapping};
    const inv = {};
    Object.entries(state.mapping).forEach(([x,y]) => { inv[y] = x; });
    return inv;
  }

  function isFunction(){
    // exactly one image for each left element
    const lefts = currentLeftItems().map(it => it.id);
    const f = currentLeftToRight();
    return lefts.every(id => id in f);
  }

  function isInjective(){
    const f = currentLeftToRight();
    const counts = {};
    for (const k in f){ counts[f[k]] = (counts[f[k]]||0)+1; }
    return Object.values(counts).every(c => c === 1);
  }

  function isSurjective(){
    const rights = currentRightItems().map(it => it.id);
    const used = new Set(Object.values(currentLeftToRight()));
    return rights.every(id => used.has(id));
  }

  function isBijection(){ return isFunction() && isInjective() && isSurjective(); }

  function diagnostics(){
    const lefts = currentLeftItems().map(it => it.id);
    const rights = currentRightItems().map(it => it.id);
    const f = currentLeftToRight();

    const unmapped = lefts.filter(id => !(id in f)).length;

    const counts = {};
    Object.values(f).forEach(v => counts[v] = (counts[v]||0)+1);
    const collisions = Object.values(counts).filter(c => c>1).length;

    const used = new Set(Object.values(f));
    const unusedRight = rights.filter(id => !used.has(id)).length;

    return { unmapped, collisions, unusedRight };
  }

  function updateProperties(){
    const chip = (ok, txt) => `<span class="prop-chip ${ok?'good':'bad'}">${ok?'✓':'✗'} ${txt}</span>`;
    propChips.innerHTML = [
      chip(isFunction(), "Function (each left has exactly one image)"),
      chip(isInjective(), "Injective (1–1)"),
      chip(isSurjective(), "Surjective (onto)"),
      chip(isBijection(), "Bijection ⇒ Invertible"),
    ].join(" ");

    const d = diagnostics();
    diags.innerHTML = [
      `<span class="diag"><strong>Unmapped in D:</strong> ${d.unmapped}</span>`,
      `<span class="diag"><strong>Colliding targets:</strong> ${d.collisions}</span>`,
      `<span class="diag"><strong>Unused in E:</strong> ${d.unusedRight}</span>`,
    ].join(" ");
  }

  function updateScore(){
    const leftCount = currentLeftItems().length;
    const f = currentLeftToRight();
    const assigned = Object.keys(f).length;

    // mapping points: +1 per assigned left, +2 injective, +2 surjective
    const mapPts = assigned + (isInjective()?2:0) + (isSurjective()?2:0);
    const mapMax = leftCount + 4;

    const total = mapPts, totalMax = mapMax;
    const pct = totalMax ? Math.round(100 * total / totalMax) : 0;
    scoreText.textContent = `Score: ${total}/${totalMax} (${pct}%)`;
    scoreFill.style.width = `${pct}%`;
  }

  function updateAll(){
    updateProperties();
    updateScore();
  }

  // -------------------- Controls --------------------
  document.getElementById("btnNewFunc").addEventListener("click", async () => {
    await loadPuzzle();
  });

  document.getElementById("btnClearMap").addEventListener("click", () => {
    state.mapping = {};
    drawLinks();
    refreshMaptoBadges();
    updateAll();
  });

  document.getElementById("btnInvert").addEventListener("click", () => {
    if (!isBijection()){
      alert("Map is not a bijection, so no inverse function exists.");
      return;
    }
    state.view = (state.view === "D2E") ? "E2D" : "D2E";
    buildColumns();
    drawLinks();
    updateAll();
  });

  document.getElementById("lockLinks").addEventListener("change", (e) => {
    state.lockLinks = e.target.checked;
  });

  window.addEventListener("resize", () => {
    drawLinks();
  });

  // -------------------- Countability Lab --------------------
  function updateN(){
    const n = parseInt(nRange.value, 10);
    nVal.textContent = String(n);
    fVal.textContent = String(n+1);
    gVal.textContent = String(2*n);
    hVal.textContent = String(2*n+1);
  }
  nRange.addEventListener("input", updateN);

  // -------------------- Boot --------------------
  (async function boot(){
    await loadPuzzle();
    updateN();
  })();
})();
</script>
{% endblock %}
