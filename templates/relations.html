{% extends "index.html" %}
{% block page_title %}Relations & Functions — Single View Game (Fossils){% endblock %}

{% block controls %}
<div class="controls" aria-label="Game controls" style="flex-wrap:wrap;">
  <!-- LAYERS (what to show) -->
  <div class="chips" id="layerChips" style="flex-wrap:wrap; gap:6px;"></div>

  <!-- EDIT MODES (what you can change by clicking) -->
  <div class="chips" id="editChips" style="flex-wrap:wrap; gap:6px;"></div>

  <!-- Utility -->
  <button id="btnReset" class="btn">Reset</button>
  <label class="switch btn"><input id="lockNodes" type="checkbox" /><span id="txtLock">Lock nodes</span></label>
  <label class="switch btn"><input id="showLabels" type="checkbox" checked /><span id="txtShow">Show labels</span></label>

  <!-- Language toggle beside "Show labels" -->
  <div class="chips" style="display:inline-flex; gap:6px;">
    <div id="langEN" class="chip" title="English">ENG</div>
    <div id="langHU" class="chip" title="Magyar">HUN</div>
  </div>
</div>
{% endblock %}

{% block content %}
<section class="canvas-card" aria-label="Single view canvas">
  <canvas id="stage" role="img" aria-label="Relations & Functions single view canvas"></canvas>
</section>

<aside>
  <div>
    <h2 id="panelTitle">Learn by Doing</h2>
    <div class="sets-top">
      <div class="badge" id="datasetLabel">Dataset: <strong>Fossils • Beds • Environments</strong></div>
      <div class="tips">
        <div class="pill" id="tipWord" style="margin:6px 0;">Tip</div>
        <div id="tipLine1">Choose an <b>Edit mode</b>, then click <i>source → target</i> to (un)link.</div>
        <div id="tipLine2">Use <b>Layers</b> to show/hide R, f, g, g∘f, Bed‑relation, Equivalence.</div>
      </div>
    </div>
  </div>

  <div class="summary" id="checksBox">
    <h2 id="checksHdr">Live Checks (8 core ideas)</h2>

    <!-- 1 Binary relation -->
    <div class="row">
      <div class="lhs"><strong id="c1Title">Binary Relation R ⊆ Fossils×Beds</strong></div>
      <div class="k" id="c1Val">R: 0 pairs</div>
    </div>

    <!-- 2 Properties -->
    <div class="row">
      <div class="lhs"><strong id="c2Title">Properties on Bed↔Bed relation</strong>
        <span class="pill" style="margin-left:6px;">R_B:</span>
        <span id="propChips" class="chips" style="margin-left:6px;"></span>
      </div>
      <div class="k" style="min-width:170px;">
        <div id="c2Props" style="display:grid; grid-template-columns:auto auto; gap:4px 10px; text-align:left;"></div>
      </div>
    </div>

    <!-- 3 Equivalence -->
    <div class="row">
      <div class="lhs"><strong id="c3Title">Equivalence Relation (classes on fossils)</strong></div>
      <div class="k" id="c3Val">3 classes</div>
    </div>

    <!-- 4 Partial order -->
    <div class="row">
      <div class="lhs"><strong id="c4Title">Partial Order ≤ (stratigraphy)</strong></div>
      <div class="k" id="c4Val">True</div>
    </div>

    <!-- 5 Function -->
    <div class="row">
      <div class="lhs"><strong id="c5Title">Function f: Fossils → Beds</strong></div>
      <div class="k" id="c5Val">Function? —</div>
    </div>

    <!-- 6 Types -->
    <div class="row">
      <div class="lhs"><strong id="c6Title">Types for f (injective / surjective / bijective)</strong></div>
      <div class="k" id="c6Val">inj —, surj —, bij —</div>
    </div>

    <!-- 7 Composition -->
    <div class="row">
      <div class="lhs"><strong id="c7Title">Composition g∘f: Fossils → Environments</strong></div>
      <div class="k" id="c7Val">distinct envs: —</div>
    </div>

    <!-- 8 Inverse -->
    <div class="row">
      <div class="lhs"><strong id="c8Title">Inverse demo on g∘f (pick 4 fossils)</strong>
        <span id="invChips" class="chips" style="margin-left:6px;"></span>
      </div>
      <div class="k" id="c8Val">f⁻¹ exists? —</div>
    </div>
  </div>
</aside>

<section class="explain-card" aria-live="polite" aria-label="Bottom help">
  <div class="explain-head">
    <span class="badge" id="legendHdr">Legend</span>
    <code>R</code>, <code>f</code>, <code>g</code>, <code>g∘f</code>, <code>R_B</code>
  </div>
  <div id="legendTxt" class="explain-body">
    <span style="color:#58c6ff;">R</span> (relation),
    <span style="color:#34d399;">f</span> (function Fossil→Bed),
    <span style="color:#f59e0b;">g</span> (Bed→Environment),
    <span style="color:#facc15;">g∘f</span> (composite),
    <span style="color:#a78bfa;">R_B</span> (Beds’ own relation: identity / adjacent / ≤ / custom).
  </div>
</section>
{% endblock %}

{% block scripts %}
<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (x1,y1,x2,y2)=>Math.hypot(x1-x2,y1-y2);
  const $ = id=>document.getElementById(id);
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  // Colors
  const COL = {
    frame: "#0c1220",
    border: "#223045",
    R: "#58c6ff",
    f: "#34d399",
    g: "#f59e0b",
    comp: "#facc15",
    bedsR: "#a78bfa",
    hulls: ["rgba(122, 162, 255, 0.15)", "rgba(52, 211, 153, 0.14)", "rgba(250, 204, 21, 0.14)"],
    hullBorders: ["#7aa2ff","#34d399","#facc15"]
  };

  // Language pack
  const L = {
    en: {
      layers: "Layers",
      edit: "Edit",
      layer_R: "Show R",
      layer_f: "Show f",
      layer_g: "Show g",
      layer_comp: "Show g∘f",
      layer_bedsR: "Show Beds‑relation",
      layer_equiv: "Show Equivalence",
      edit_none: "Move only",
      edit_R: "Edit R (Fossil→Bed)",
      edit_f: "Edit f (Fossil→Bed)",
      edit_g: "Edit g (Bed→Env)",
      edit_bR: "Edit Beds‑relation",
      reset: "Reset",
      lock: "Lock nodes",
      show: "Show labels",
      dataset: "Dataset",
      tip: "Tip",
      tip1: "Choose an Edit mode, then click source → target to toggle an arrow.",
      tip2: "Use Layers to show/hide R, f, g, g∘f, bed‑relation, equivalence hulls.",
      panel: "Learn by Doing",
      checks: "Live Checks (8 core ideas)",
      c1: "Binary Relation R ⊆ Fossils×Beds",
      c2: "Properties on Bed↔Bed relation",
      c3: "Equivalence Relation (classes on fossils)",
      c4: "Partial Order ≤ (stratigraphy)",
      c5: "Function f: Fossils → Beds",
      c6: "Types for f (injective / surjective / bijective)",
      c7: "Composition g∘f: Fossils → Environments",
      c8: "Inverse demo on g∘f (pick 4 fossils)",
      propPick: "Pick:",
      reflexive: "Reflexive",
      symmetric: "Symmetric",
      antisym: "Antisymmetric",
      trans: "Transitive",
      legend: "Legend",
      invExistsYes: "Yes (bijective on chosen fossils ↔ environments)",
      invExistsNo: "No"
    },
    hu: {
      layers: "Rétegek",
      edit: "Szerkesztés",
      layer_R: "R mutatása",
      layer_f: "f mutatása",
      layer_g: "g mutatása",
      layer_comp: "g∘f mutatása",
      layer_bedsR: "Ágy‑reláció mutatása",
      layer_equiv: "Ekvivalencia mutatása",
      edit_none: "Csak mozgatás",
      edit_R: "R szerk. (Fosszília→Ágy)",
      edit_f: "f szerk. (Fosszília→Ágy)",
      edit_g: "g szerk. (Ágy→Körny.)",
      edit_bR: "Ágy‑reláció szerk.",
      reset: "Visszaállítás",
      lock: "Objektumok zárolása",
      show: "Címkék mutatása",
      dataset: "Adatkészlet",
      tip: "Tipp",
      tip1: "Válassz szerkesztési módot, majd kattints forrás → cél nyíl hozzáadásához/törléséhez.",
      tip2: "A Rétegek kapcsolóival rejtsd/mutasd az R, f, g, g∘f, ágy‑reláció, ekvivalencia elemeket.",
      panel: "Játékos tanulás",
      checks: "Élő ellenőrzések (8 alapötlet)",
      c1: "Bináris reláció R ⊆ Fosszíliák×Ágyak",
      c2: "Relációtulajdonságok (Ágy↔Ágy)",
      c3: "Ekvivalenciareláció (osztályok a fosszíliákon)",
      c4: "Részbenrendezés ≤ (rétegtan)",
      c5: "Függvény f: Fosszíliák → Ágyak",
      c6: "Függvénytípusok f‑re (injektív / szürjektív / bijektív)",
      c7: "Összetétel g∘f: Fosszíliák → Környezetek",
      c8: "Inverz demó g∘f‑re (válassz 4 fosszíliát)",
      propPick: "Válaszd:",
      reflexive: "Reflexív",
      symmetric: "Szimmetrikus",
      antisym: "Antiszimmetrikus",
      trans: "Tranzitív",
      legend: "Jelmagyarázat",
      invExistsYes: "Igen (bijekció a választott fosszíliák ↔ környezetek között)",
      invExistsNo: "Nem"
    }
  };

  // ---------- State ----------
  const canvas = $("stage");
  const ctx = canvas.getContext("2d");

  const state = {
    assets: null, // {fossils,beds,envs,defaults}
    nodes: [],    // {id,type:'fossil'|'bed'|'env', name,img?, order?, x,y, w,h}
    edgesR: [],   // fossil->bed general relation
    edgesF: [],   // fossil->bed function
    edgesG: [],   // bed->env fixed (editable)
    edgesRB: [],  // bed->bed relation for properties
    invPick: new Set(), // selected fossils for inverse demo
    layers: { R:true, f:true, g:true, comp:true, bedsR:true, equiv:true },
    edit: "none", // 'none'|'R'|'f'|'g'|'bR'
    lang: (localStorage.getItem("relations.lang") || "en"),
    needsDraw: true,
    drag: null,
    propKey: "leq" // which predefined bed relation is loaded
  };

  // ---------- Layout helpers ----------
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    state.needsDraw = true;
  }
  window.addEventListener("resize", resizeCanvas);

  function placeColumns(){
    const foss = state.nodes.filter(n=>n.type==='fossil');
    const beds = state.nodes.filter(n=>n.type==='bed');
    const envs = state.nodes.filter(n=>n.type==='env');

    const rows = (n) => {
      const base=0.18, step=(0.64)/(Math.max(1,n)-1 || 1);
      return Array.from({length:n}, (_,i)=> clamp(base + i*step, 0.12, 0.86));
    };

    const fossX = 0.18, bedsX = 0.50, envX = 0.82;
    const fy = rows(foss.length), by = [0.80,0.62,0.44,0.26], ey = rows(envs.length);
    foss.forEach((n,i)=>{ n.x=fossX; n.y=fy[i]; n.w=64; n.h=64; });
    // Beds ordered old→young bottom→top (by.order 1..4)
    beds.sort((a,b)=>a.order-b.order);
    beds.forEach((n,i)=>{ n.x=bedsX; n.y=by[i]; n.w=100; n.h=36; });
    envs.forEach((n,i)=>{ n.x=envX; n.y=ey[i]; n.w=110; n.h=36; });
  }

  // ---------- Build nodes / load assets ----------
  async function loadAssets(){
    const res = await fetch("/relations/api/assets");
    state.assets = await res.json();

    // Nodes
    state.nodes = [];
    state.assets.fossils.forEach(f => state.nodes.push({id:f.id, type:'fossil', name:f.name, img:f.img, x:0.18, y:0.3, w:64,h:64}));
    state.assets.beds.forEach(b => state.nodes.push({id:b.id, type:'bed', name:b.name, order:b.order, x:0.5, y:0.5, w:100,h:36}));
    state.assets.envs.forEach(e => state.nodes.push({id:e.id, type:'env', name:e.name, x:0.82, y:0.5, w:110,h:36}));
    placeColumns();

    // Edges
    state.edgesR = state.assets.defaults.R_pairs.map(([a,b])=>({from:a,to:b}));
    state.edgesF = state.assets.defaults.f_pairs.map(([a,b])=>({from:a,to:b}));
    state.edgesG = state.assets.defaults.g_pairs.map(([a,b])=>({from:a,to:b}));
    state.edgesRB = state.assets.defaults.beds_relations[state.propKey].map(([a,b])=>({from:a,to:b}));

    // Inverse default pick: choose 4 fossils
    ["iguanodon","fish","ammonoidea","ankylosaurus"].forEach(id => state.invPick.add(id));

    buildUI();
    applyLang();
    updateAllChecks();
    state.needsDraw = true;
  }

  // ---------- UI builders ----------
  function buildUI(){
    // Layers
    const LAY = [
      ["R","layer_R"], ["f","layer_f"], ["g","layer_g"], ["comp","layer_comp"], ["bedsR","layer_bedsR"], ["equiv","layer_equiv"]
    ];
    const lc = $("layerChips"); lc.innerHTML = "";
    addLabelChip(lc, L[state.lang].layers);
    LAY.forEach(([key, lab])=>{
      const chip = makeChip(L[state.lang][lab], state.layers[key], () => {
        state.layers[key] = !state.layers[key];
        chip.classList.toggle("selected", state.layers[key]);
        state.needsDraw = true;
      });
      lc.appendChild(chip);
    });

    // Edit modes
    const EDIT = [["none","edit_none"],["R","edit_R"],["f","edit_f"],["g","edit_g"],["bR","edit_bR"]];
    const ec = $("editChips"); ec.innerHTML = "";
    addLabelChip(ec, L[state.lang].edit);
    EDIT.forEach(([key, lab])=>{
      const chip = makeChip(L[state.lang][lab], state.edit===key, () => {
        state.edit = key;
        [...ec.querySelectorAll(".chip")].forEach(c=>c.classList.remove("selected"));
        chip.classList.add("selected");
      });
      ec.appendChild(chip);
    });

    // Props chooser for bed↔bed relation
    const propBox = $("propChips"); propBox.innerHTML = "";
    const options = [
      ["identity","Identity"], ["adjacent","Adjacent"], ["leq","≤ stratigraphic"]
    ];
    options.forEach(([k,label])=>{
      const chip = makeChip(label + (k==="leq"?" (≤)":""), state.propKey===k, ()=>{
        state.propKey = k;
        // load predefined pairs; if identity/adjacent/leq
        const pairs = state.assets.defaults.beds_relations[k];
        state.edgesRB = pairs.map(([a,b])=>({from:a,to:b}));
        // recompute checks
        updatePropertiesChecks();
        state.needsDraw = true;
        // toggle UI
        [...propBox.querySelectorAll(".chip")].forEach(c=>c.classList.remove("selected"));
        chip.classList.add("selected");
      });
      propBox.appendChild(chip);
    });

    // Inverse pick chips
    const invBox = $("invChips"); invBox.innerHTML = "";
    state.assets.fossils.forEach(f=>{
      const chip = makeChip(f.name, state.invPick.has(f.id), ()=>{
        if (state.invPick.has(f.id)) state.invPick.delete(f.id);
        else if (state.invPick.size<4) state.invPick.add(f.id);
        // force at most 4
        while (state.invPick.size>4) { state.invPick.delete([...state.invPick][0]); }
        updateInverseCheck();
        state.needsDraw = true;
        // refresh selection UI
        [...invBox.querySelectorAll(".chip")].forEach(c=>c.classList.remove("selected"));
        state.assets.fossils.forEach((ff, i)=>{
          if (state.invPick.has(ff.id)) invBox.children[i].classList.add("selected");
        });
      });
      invBox.appendChild(chip);
    });

    // Language chips
    $("langEN").onclick = ()=>{ state.lang="en"; localStorage.setItem("relations.lang","en"); applyLang(); };
    $("langHU").onclick = ()=>{ state.lang="hu"; localStorage.setItem("relations.lang","hu"); applyLang(); };

    // Reset
    $("btnReset").onclick = ()=>{
      state.layers = {R:true,f:true,g:true,comp:true,bedsR:true,equiv:true};
      state.edit = "none";
      state.propKey = "leq";
      state.edgesR = state.assets.defaults.R_pairs.map(([a,b])=>({from:a,to:b}));
      state.edgesF = state.assets.defaults.f_pairs.map(([a,b])=>({from:a,to:b}));
      state.edgesG = state.assets.defaults.g_pairs.map(([a,b])=>({from:a,to:b}));
      state.edgesRB = state.assets.defaults.beds_relations[state.propKey].map(([a,b])=>({from:a,to:b}));
      state.invPick = new Set(["iguanodon","fish","ammonoidea","ankylosaurus"]);
      placeColumns();
      buildUI();
      applyLang();
      updateAllChecks();
      state.needsDraw = true;
    };

    $("showLabels").onchange = ()=> state.needsDraw = true;
  }

  function addLabelChip(parent, label){
    const span = document.createElement("span");
    span.className = "pill";
    span.textContent = label;
    parent.appendChild(span);
  }

  function makeChip(text, selected, onClick){
    const chip = document.createElement("div");
    chip.className = "chip";
    chip.textContent = text;
    if (selected) chip.classList.add("selected");
    chip.onclick = onClick;
    return chip;
  }

  // ---------- Language application ----------
  function applyLang(){
    const t = L[state.lang];
    $("btnReset").textContent = t.reset;
    $("txtLock").textContent = t.lock;
    $("txtShow").textContent = t.show;
    $("datasetLabel").innerHTML = t.dataset + ': <strong>Fossils • Beds • Environments</strong>';
    $("tipWord").textContent = t.tip;
    $("tipLine1").textContent = t.tip1;
    $("tipLine2").textContent = t.tip2;
    $("panelTitle").textContent = t.panel;
    $("checksHdr").textContent = t.checks;

    $("c1Title").textContent = t.c1;
    $("c2Title").textContent = t.c2;
    $("c3Title").textContent = t.c3;
    $("c4Title").textContent = t.c4;
    $("c5Title").textContent = t.c5;
    $("c6Title").textContent = t.c6;
    $("c7Title").textContent = t.c7;
    $("c8Title").textContent = t.c8;

    $("legendHdr").textContent = t.legend;
    $("legendTxt").innerHTML =
      `<span style="color:${COL.R};">R</span> (relation),
       <span style="color:${COL.f};">f</span> (Fossil→Bed),
       <span style="color:${COL.g};">g</span> (Bed→Environment),
       <span style="color:${COL.comp};">g∘f</span> (composite),
       <span style="color:${COL.bedsR};">R_B</span> (Beds relation).`;

    // Rebuild layer & edit chips with localized labels
    buildUI();
    updateAllChecks();

    // Toggle selected language UI
    $("langEN").classList.toggle("selected", state.lang==='en');
    $("langHU").classList.toggle("selected", state.lang==='hu');
  }

  // ---------- Picking & interaction ----------
  function pickNode(px,py){
    for (let i=state.nodes.length-1;i>=0;i--){
      const n = state.nodes[i];
      const x=n.x*canvas.clientWidth, y=n.y*canvas.clientHeight;
      if (n.type==='fossil'){
        if (dist(px,py,x,y)<=36) return n;
      } else {
        if (px>=x-n.w/2 && px<=x+n.w/2 && py>=y-n.h/2 && py<=y+n.h/2) return n;
      }
    }
    return null;
  }

  function togglePair(list, a,b, uniqueFrom=false){
    if (uniqueFrom){
      // Remove all existing out from 'a'
      for (let i=list.length-1;i>=0;--i) if (list[i].from===a) list.splice(i,1);
      list.push({from:a,to:b});
      return;
    }
    const idx = list.findIndex(e=>e.from===a && e.to===b);
    if (idx>=0) list.splice(idx,1); else list.push({from:a,to:b});
  }

  canvas.addEventListener("pointerdown", (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX-rect.left, y = ev.clientY-rect.top;
    const n = pickNode(x,y);
    if (!n) { state.drag=null; return; }

    // EDIT MODES
    if (state.edit !== "none"){
      // start/pair logic
      if (!state.drag || !state.drag.intent){
        state.drag = { intent:"edge", from:n };
        return;
      } else if (state.drag.intent==="edge"){
        const a = state.drag.from;
        const b = n;
        if (a.id!==b.id){
          if (state.edit==="R" && a.type==='fossil' && b.type==='bed'){
            togglePair(state.edgesR, a.id,b.id,false);
          } else if (state.edit==="f" && a.type==='fossil' && b.type==='bed'){
            togglePair(state.edgesF, a.id,b.id,true);
          } else if (state.edit==="g" && a.type==='bed' && b.type==='env'){
            togglePair(state.edgesG, a.id,b.id,true);
          } else if (state.edit==="bR" && a.type==='bed' && b.type==='bed'){
            togglePair(state.edgesRB, a.id,b.id,false);
          }
          state.drag = null;
          updateAllChecks();
          state.needsDraw = true;
          return;
        }
      }
    }

    // DRAGGING
    if ($("lockNodes").checked) { state.drag=null; return; }
    state.drag = { intent:"move", id:n.id, dx:n.x*canvas.clientWidth-x, dy:n.y*canvas.clientHeight-y };
  });

  window.addEventListener("pointermove", (ev)=>{
    if (!state.drag || state.drag.intent!=="move") return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX-rect.left, y = ev.clientY-rect.top;
    const n = state.nodes.find(nn=>nn.id===state.drag.id);
    if (!n) return;
    n.x = clamp((x + state.drag.dx)/canvas.clientWidth, 0.06, 0.94);
    n.y = clamp((y + state.drag.dy)/canvas.clientHeight, 0.08, 0.92);
    state.needsDraw = true;
  });
  window.addEventListener("pointerup", ()=> state.drag=null);

  // ---------- Checks / logic ----------
  function updateAllChecks(){
    updateC1_R();
    updatePropertiesChecks();
    updateC3_Equiv();
    updateC4_Poset();
    updateC5_Function();
    updateC6_Types();
    updateC7_Composition();
    updateInverseCheck();
  }

  function updateC1_R(){
    $("c1Val").textContent = `R: ${state.edgesR.length} pairs`;
    if (state.lang==='hu') $("c1Val").textContent = `R: ${state.edgesR.length} pár`;
  }

  function listPairsToMap(list){
    const m = new Map();
    list.forEach(e=>{
      if (!m.has(e.from)) m.set(e.from, new Set());
      m.get(e.from).add(e.to);
    });
    return m;
  }

  function updatePropertiesChecks(){
    const T = L[state.lang];
    const ids = state.nodes.filter(n=>n.type==='bed').map(n=>n.id);
    const has = (a,b) => state.edgesRB.some(e=> e.from===a && e.to===b);
    // Reflexive
    const reflexive = ids.every(a => has(a,a));
    // Symmetric
    const symmetric = state.edgesRB.every(e => has(e.to, e.from));
    // Antisymmetric
    const antisym = state.edgesRB.every(e => (e.from===e.to) || !has(e.to, e.from));
    // Transitive
    let trans = true;
    outer: for (const e1 of state.edgesRB){
      for (const e2 of state.edgesRB){
        if (e1.to===e2.from){
          if (!has(e1.from, e2.to)){ trans=false; break outer; }
        }
      }
    }
    const grid = $("c2Props"); grid.innerHTML = "";
    grid.appendChild(makePropRow(T.reflexive, reflexive));
    grid.appendChild(makePropRow(T.symmetric, symmetric));
    grid.appendChild(makePropRow(T.antisym, antisym));
    grid.appendChild(makePropRow(T.trans, trans));
  }

  function makePropRow(label, ok){
    const div = document.createElement("div");
    div.innerHTML = `<strong>${label}:</strong> ${ok? "✓":"✗"}`;
    return div;
  }

  function updateC3_Equiv(){
    // Count classes
    const classes = state.assets.defaults.equiv_classes;
    const n = Object.keys(classes).length;
    $("c3Val").textContent = `${n} classes`;
    if (state.lang==='hu') $("c3Val").textContent = `${n} osztály`;
  }

  function updateC4_Poset(){
    // Using ≤ as default R_B = leq ensures it's a partial order
    $("c4Val").textContent = "True";
    if (state.lang==='hu') $("c4Val").textContent = "Igaz";
  }

  function updateC5_Function(){
    const fossils = state.nodes.filter(n=>n.type==='fossil').map(n=>n.id);
    const beds = state.nodes.filter(n=>n.type==='bed').map(n=>n.id);
    const out = new Map(); fossils.forEach(a=>out.set(a,0));
    const inn = new Map(); beds.forEach(b=>inn.set(b,0));
    state.edgesF.forEach(e=>{ out.set(e.from,(out.get(e.from)||0)+1); inn.set(e.to,(inn.get(e.to)||0)+1); });
    const isFunc = fossils.every(a => (out.get(a)||0)===1);
    $("c5Val").textContent = (state.lang==='hu')
      ? `Függvény? ${isFunc ? "✓ Igen" : "✗ Nem"}`
      : `Function? ${isFunc ? "✓ Yes" : "✗ No"}`;
  }

  function updateC6_Types(){
    const fossils = state.nodes.filter(n=>n.type==='fossil').map(n=>n.id);
    const beds = state.nodes.filter(n=>n.type==='bed').map(n=>n.id);
    const out = new Map(); fossils.forEach(a=>out.set(a,0));
    const inn = new Map(); beds.forEach(b=>inn.set(b,0));
    state.edgesF.forEach(e=>{ out.set(e.from,(out.get(e.from)||0)+1); inn.set(e.to,(inn.get(e.to)||0)+1); });
    const isFunc = fossils.every(a => (out.get(a)||0)===1);
    const injective = beds.every(b => (inn.get(b)||0) <= 1);
    const surjective = beds.every(b => (inn.get(b)||0) >= 1);
    const bij = isFunc && injective && surjective;
    const t = (x)=> x ? "✓" : "✗";
    $("c6Val").textContent = `inj ${t(injective)}, surj ${t(surjective)}, bij ${t(bij)}`;
    if (state.lang==='hu'){
      $("c6Title").textContent = L.hu.c6;
    } else {
      $("c6Title").textContent = L.en.c6;
    }
  }

  function computeComp(){
    // comp edges a->env using f then g
    const mapF = new Map(); state.edgesF.forEach(e=> mapF.set(e.from, e.to));
    const mapG = new Map(); state.edgesG.forEach(e=> mapG.set(e.from, e.to));
    const comp = [];
    for (const [a,b] of mapF.entries()){
      const env = mapG.get(b);
      if (env) comp.push({from:a,to:env});
    }
    return comp;
  }

  function updateC7_Composition(){
    const comp = computeComp();
    const envSet = new Set(comp.map(e=>e.to));
    const count = envSet.size;
    $("c7Val").textContent = `distinct envs: ${count}`;
    if (state.lang==='hu') $("c7Val").textContent = `különböző környezetek: ${count}`;
  }

  function updateInverseCheck(){
    const comp = computeComp();
    const pick = new Set(state.invPick);
    // Only consider picked fossils
    const sub = comp.filter(e=> pick.has(e.from));
    const envs = state.nodes.filter(n=>n.type==='env').map(n=>n.id);
    // Condition: pick exactly 4 fossils, and sub uses all 4 envs exactly once
    const okSize = pick.size===4;
    const hit = new Map(); envs.forEach(id=>hit.set(id,0));
    sub.forEach(e=> hit.set(e.to,(hit.get(e.to)||0)+1));
    const allOne = envs.every(id => hit.get(id)===1);
    const exists = okSize && allOne;
    $("c8Val").textContent = exists ? (state.lang==='hu'? L.hu.invExistsYes : L.en.invExistsYes)
                                    : (state.lang==='hu'? L.hu.invExistsNo : L.en.invExistsNo);
  }

  // ---------- Drawing ----------
  const imgCache = new Map();
  function getImage(url){
    return new Promise((resolve)=>{
      if (imgCache.has(url)) { resolve(imgCache.get(url)); return; }
      const im = new Image();
      im.crossOrigin = "anonymous";
      im.onload = ()=>{ imgCache.set(url,im); resolve(im); };
      im.onerror = ()=> resolve(null);
      im.src = url;
    });
  }

  function rr(x,y,w,h,r){
    const R = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+R,y);
    ctx.arcTo(x+w,y, x+w,y+h, R);
    ctx.arcTo(x+w,y+h, x,y+h, R);
    ctx.arcTo(x,y+h, x,y, R);
    ctx.arcTo(x,y, x+w,y, R);
    ctx.closePath();
  }

  function drawEdgeCurve(ax,ay,bx,by,color){
    ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 2.2;
    const mx = (ax+bx)/2, my = (ay+by)/2 - 18;
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.quadraticCurveTo(mx,my,bx,by); ctx.stroke();
    const ang = Math.atan2(by-my, bx-mx), s=6;
    ctx.beginPath();
    ctx.moveTo(bx,by);
    ctx.lineTo(bx - s*Math.cos(ang - Math.PI/6), by - s*Math.sin(ang - Math.PI/6));
    ctx.lineTo(bx - s*Math.cos(ang + Math.PI/6), by - s*Math.sin(ang + Math.PI/6));
    ctx.closePath(); ctx.fill();
  }

  function nodeXY(id){
    const n = state.nodes.find(nn=>nn.id===id);
    return n ? [n.x*canvas.clientWidth, n.y*canvas.clientHeight] : [0,0];
  }

  function drawEquivalenceHulls(){
    if (!state.layers.equiv) return;
    const classes = state.assets.defaults.equiv_classes;
    const groups = Object.values(classes);
    groups.forEach((ids, gi)=>{
      const pts = ids.map(id => nodeXY(id));
      if (!pts.length) return;
      // simple rounded bounding box
      let minx=1e9,miny=1e9,maxx=-1e9,maxy=-1e9;
      pts.forEach(([x,y])=>{ minx=Math.min(minx,x-44); maxx=Math.max(maxx,x+44); miny=Math.min(miny,y-44); maxy=Math.max(maxy,y+44); });
      const pad=8;
      const x=minx-pad, y=miny-pad, w=(maxx-minx)+pad*2, h=(maxy-miny)+pad*2;
      ctx.save();
      ctx.fillStyle = COL.hulls[gi % COL.hulls.length];
      ctx.strokeStyle = COL.hullBorders[gi % COL.hullBorders.length];
      ctx.lineWidth = 1.5;
      rr(x,y,w,h,14);
      ctx.fill(); ctx.stroke();
      ctx.restore();
    });
  }

  async function draw(){
    state.needsDraw = false;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // Frame
    ctx.fillStyle = COL.frame; ctx.strokeStyle = COL.border; ctx.lineWidth = 1.5;
    rr(8.5,8.5, w-17, h-17, 12); ctx.fill(); ctx.stroke();

    // Draw layers (edges first)
    if (state.layers.bedsR){
      // bed↔bed edges
      for (const e of state.edgesRB){
        const [ax,ay] = nodeXY(e.from); const [bx,by] = nodeXY(e.to);
        drawEdgeCurve(ax,ay,bx,by,COL.bedsR);
      }
    }
    if (state.layers.R){
      for (const e of state.edgesR){
        const [ax,ay]=nodeXY(e.from), [bx,by]=nodeXY(e.to);
        drawEdgeCurve(ax,ay,bx,by,COL.R);
      }
    }
    if (state.layers.g){
      for (const e of state.edgesG){
        const [ax,ay]=nodeXY(e.from), [bx,by]=nodeXY(e.to);
        drawEdgeCurve(ax,ay,bx,by,COL.g);
      }
    }
    if (state.layers.f){
      for (const e of state.edgesF){
        const [ax,ay]=nodeXY(e.from), [bx,by]=nodeXY(e.to);
        drawEdgeCurve(ax,ay,bx,by,COL.f);
      }
    }
    if (state.layers.comp){
      for (const e of computeComp()){
        const [ax,ay]=nodeXY(e.from), [bx,by]=nodeXY(e.to);
        drawEdgeCurve(ax,ay,bx,by,COL.comp);
      }
    }

    // Equivalence hulls behind fossils
    drawEquivalenceHulls();

    // Nodes
    const showLabels = $("showLabels").checked;
    for (const n of state.nodes){
      const cx = n.x*w, cy = n.y*h;
      if (n.type==='fossil'){
        const R=34;
        ctx.save();
        ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.closePath(); ctx.clip();
        const im = await getImage(state.assets.fossils.find(f=>f.id===n.id)?.img);
        if (im){
          const scale = Math.max((2*R)/im.width, (2*R)/im.height);
          const iw = im.width*scale, ih=im.height*scale;
          ctx.drawImage(im, cx-iw/2, cy-ih/2, iw, ih);
        } else { ctx.fillStyle="#1b2536"; ctx.fill(); }
        ctx.restore();
        ctx.strokeStyle="#5aa7ff"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();
        if (showLabels) drawLabel(cx, cy+R+12, n.name);
      } else {
        ctx.fillStyle="#0e1523"; ctx.strokeStyle="#2b3a52"; ctx.lineWidth=1.2;
        rr(cx-n.w/2, cy-n.h/2, n.w, n.h, 8); ctx.fill(); ctx.stroke();
        ctx.fillStyle="#cfe0ff"; ctx.font="500 12px system-ui,-apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(n.name, cx, cy);
      }
    }
  }

  function drawLabel(cx, y, text){
    ctx.font="500 12px system-ui,-apple-system, Segoe UI, Roboto, Arial";
    const pad=8, tw = ctx.measureText(text).width + pad*2, th=20;
    ctx.fillStyle="rgba(12,18,32,0.92)";
    rr(cx - tw/2, y-th/2, tw, th, 8); ctx.fill();
    ctx.strokeStyle="#233040"; ctx.lineWidth=1;
    rr(cx - tw/2, y-th/2, tw, th, 8); ctx.stroke();
    ctx.fillStyle="#d7e6ff"; ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(text, cx, y);
  }

  // ---------- Loop ----------
  function loop(){ if (state.needsDraw) draw(); requestAnimationFrame(loop); }

  // ---------- Boot ----------
  $("lockNodes").checked = false;
  (async function boot(){
    resizeCanvas();
    await loadAssets();
    loop();
  })();
})();
</script>
{% endblock %}
