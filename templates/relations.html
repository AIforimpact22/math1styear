<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Relations & Functions — Porosity Grid</title>
<style>
  :root{
    --bg:#0b1220; --card:#0c1628; --ink:#d7e6ff; --muted:#95a3b8; --line:#223045;
    --accent:#7cb1ff; --ok:#34d399; --bad:#f87171; --warn:#fbbf24;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0a1120,#0b1322 65%);color:var(--ink);
            font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header,main{max-width:1200px;margin:20px auto;padding:0 16px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  h1{font-size:20px;margin:0;color:#cfe0ff;font-weight:700}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{background:#122038;border:1px solid #1e2b42;color:#cfe0ff;padding:8px 12px;border-radius:10px;cursor:pointer}
  .btn:hover{background:#162744}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .btn.active{box-shadow:0 0 0 2px #3b82f6 inset}
  .switch{display:inline-flex;align-items:center;gap:6px}
  .lang{display:flex;gap:6px;margin-left:6px}
  main{display:grid;grid-template-columns:2fr 1fr;gap:16px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:12px}
  .canvas-card{position:relative}
  canvas{width:100%;height:66vh;display:block;border-radius:12px}
  h2{font-size:16px;margin:4px 0 8px;color:#cfe0ff}
  .badge{display:inline-block;background:#10223b;border:1px solid #20314a;color:#cfe0ff;padding:4px 8px;border-radius:999px;font-size:12px}
  .pill{display:inline-block;background:#0f1c31;border:1px solid #1b2a41;color:#a7bfdf;padding:2px 8px;border-radius:999px;font-size:12px}
  .tiny{font-size:12px}
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .chip{display:inline-flex;align-items:center;gap:6px;background:#101b30;border:1px solid #1a2a45;color:#cfe0ff;padding:6px 10px;border-radius:999px;font-size:12px;cursor:pointer;user-select:none}
  .chip .dot{display:inline-block;width:10px;height:10px;border-radius:999px;background:#7cb1ff}
  .chip.active{background:#0e203e;border-color:#3b82f6;box-shadow:0 0 0 1px #3b82f6 inset}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px dashed #1b2a41;padding:6px 8px;text-align:left}
  th{color:#cfe0ff}
  td.k{text-align:center;width:48px}
  .ok{color:var(--ok);font-weight:700}
  .bad{color:var(--bad);font-weight:700}
  .warn{color:var(--warn);font-weight:700}
  .score{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .bar{grid-column:1/3;height:8px;background:#111b2c;border:1px solid #1a2842;border-radius:999px;overflow:hidden}
  .fill{height:100%;width:0;background:linear-gradient(90deg,#53b4ff,#7cdeff)}
  .domain-controls{display:flex;flex-wrap:wrap;gap:6px;margin:6px 0}
  .domain-controls label{background:#101b30;border:1px solid #1a2a45;border-radius:999px;padding:4px 8px;font-size:12px}

  /* Narrative panel (below stage) */
  .narrative-card .items{display:flex;flex-direction:column;gap:8px;margin-top:6px}
  .narrative-card .item{background:#0f1c31;border:1px solid #1b2a41;border-radius:10px;padding:8px}
  .narrative-card .item h3{margin:0 0 4px 0;font-size:14px;color:#cfe0ff}
  .narrative-card .item p{margin:0;color:#b7c8e4;font-size:13px}

  .legend{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 6px 0}
  .legend .chip strong{letter-spacing:.1px}
  .toast{position:fixed;right:16px;bottom:16px;background:#10223b;border:1px solid #20314a;color:#cfe0ff;padding:8px 12px;border-radius:10px;display:none}
</style>
</head>
<body>
<header>
  <h1 id="titleText">Relations &amp; Functions — Porosity Grid</h1>
  <div class="controls" aria-label="controls">
    <button id="btnLoadM" class="btn">Load Measurements M</button>
    <button id="btnClear" class="btn">Clear All</button>
    <label class="switch btn">
      <input id="singleValued" type="checkbox"/><span id="lblSingle">Single‑valued mode</span>
    </label>
    <button id="btnSave" class="btn" disabled>Save Solution (JSON)</button>
    <a class="btn" href="https://hawkarabdulhaq.github.io/mathforbsc/relationexample.html" target="_blank" rel="noopener">Example</a>
    <div class="lang" aria-label="Language">
      <button id="langEn" class="btn active">EN</button>
      <button id="langHu" class="btn">HU</button>
    </div>
  </div>
</header>

<main>
  <!-- LEFT: Stage -->
  <section>
    <!-- Stage card (legend + grid + domain toggles) -->
    <div class="card canvas-card">
      <div class="legend">
        <span class="chip" id="chipDomain"   title=""><span class="dot" style="background:#f97316"></span><strong id="labDomain">Domain</strong> <small>(A)</small></span>
        <span class="chip" id="chipCodomain" title=""><span class="dot" style="background:#60a5fa"></span><strong id="labCodomain">Codomain</strong> <small>(B)</small></span>
        <span class="chip" id="chipRange"    title=""><span class="dot" style="background:#34d399"></span><strong id="labRange">Range</strong> <small>(Im ϕ)</small></span>
        <span class="chip" id="chipRelation" title=""><span class="dot"></span><strong id="labRelation">Relation</strong></span>
        <span class="chip" id="chipFunction" title=""><span class="dot"></span><strong id="labFunction">Function</strong></span>
        <span class="chip" id="chipNotation" title=""><span class="dot"></span><strong id="labNotation">Notation</strong></span>
        <span class="chip" id="chipCartesian" title=""><span class="dot"></span><strong id="labCartesian">A×B</strong></span>
        <span class="chip" id="chipAdvice"   title=""><span class="dot"></span><strong id="labAdvice">Data Advice</strong></span>
      </div>

      <canvas id="grid" role="img" aria-label="A×B selectable grid (x=ϕ, y=z)"></canvas>

      <div id="gridTips" class="tiny muted" style="margin-top:8px">
        • Click a cell to toggle (z,ϕ). With <strong>Single‑valued mode</strong>, a click keeps exactly one ϕ in that row (depth).<br/>
        • Un‑check a depth below to <em>restrict the domain</em> (ignored by the function test).
      </div>

      <div style="margin-top:8px">
        <div class="badge" id="actDomainTitle">Active Domain A (depths in m)</div>
        <div id="domainToggles" class="domain-controls"><!-- filled dynamically --></div>
      </div>
    </div>

    <!-- Narrative card (below stage) -->
    <div class="card narrative-card" id="narrativeCard" aria-live="polite">
      <h2 id="narrativeTitle">Concept Narrative</h2>
      <div id="narrativeIntro" class="tiny muted">
        Click any concept chip above (Domain, Codomain, Range, …) to highlight it on the grid and read the explanation here.
      </div>
      <div id="narrativeItems" class="items"><!-- filled dynamically --></div>
    </div>
  </section>

  <!-- RIGHT: Explanations & Data -->
  <aside style="display:flex;flex-direction:column;gap:12px">
    <div class="card">
      <h2 id="panelStateTitle">State A, B, Range &amp; Units</h2>
      <div class="legend" style="gap:6px">
        <span class="chip" style="cursor:default"><span class="dot" style="background:#f97316"></span><strong id="chipADepthText">A (Depth)</strong> <span id="Aset" class="mono"></span></span>
        <span class="chip" style="cursor:default"><span class="dot" style="background:#60a5fa"></span><strong id="chipBPorText">B (Porosity)</strong> <span class="mono">[0,1]</span></span>
        <span class="chip" style="cursor:default"><span class="dot" style="background:#34d399"></span><strong id="chipRangeText">Range</strong> <span id="Range" class="mono">{}</span></span>
      </div>
      <div id="unitsLine" class="tiny muted">Units: depth in <strong>m</strong>, porosity in <strong>fraction 0–1</strong>. The grid uses sampled ticks T ⊂ B for interaction.</div>
    </div>

    <div class="card" id="checkPanel">
      <h2 id="panelCheckTitle">Relation &amp; Function Checks</h2>
      <div class="score">
        <span id="fnText">Function on active A? <span class="bad">✗</span></span>
        <div class="badge" id="rangeCount">Range size: 0</div>
        <div class="bar"><div id="scoreFill" class="fill"></div></div>
      </div>
      <ul id="checkBullets" class="tiny muted" style="margin:6px 0 0 0; padding-left:18px">
        <!-- filled by i18n -->
      </ul>
      <div class="tiny"><span class="badge">Notation</span> <span id="notationText" class="mono">ϕ : A → B, ϕ(z)</span></div>
    </div>

    <div class="card">
      <h2 id="MTitle">Measurements M (given)</h2>
      <table aria-label="M table">
        <thead><tr><th id="MheadDepth">depth m</th><th id="MheadPhi">ϕ</th></tr></thead>
        <tbody id="Mbody"></tbody>
      </table>
    </div>

    <div class="card">
      <h2 id="RTitle">Selected Relation R ⊆ A×B</h2>
      <table aria-label="R table">
        <thead><tr><th id="RheadHash">#</th><th id="RheadZ">z</th><th id="RheadArrow" class="k">→</th><th id="RheadPhi">ϕ</th></tr></thead>
        <tbody id="Rbody"></tbody>
      </table>
    </div>
  </aside>
</main>

<div id="toast" class="toast">Saved to <span class="mono">relation.json</span></div>

<script>
(() => {
  // ---------- i18n ----------
  const i18n = {
    en: {
      title: "Relations & Functions — Porosity Grid",
      btnLoadM: "Load Measurements M",
      btnClear: "Clear All",
      lblSingle: "Single‑valued mode",
      btnSave: "Save Solution (JSON)",
      chipDomainLabel: "Domain", chipDomainTitle: "Highlight Domain (A)",
      chipCodomainLabel: "Codomain", chipCodomainTitle: "Highlight Codomain (B)",
      chipRangeLabel: "Range", chipRangeTitle: "Highlight Range (Im ϕ)",
      chipRelationLabel: "Relation", chipRelationTitle: "What is a relation?",
      chipFunctionLabel: "Function", chipFunctionTitle: "When is it a function?",
      chipNotationLabel: "Notation", chipNotationTitle: "Notation ϕ : A → B, ϕ(z)",
      chipCartesianLabel: "A×B", chipCartesianTitle: "Cartesian Product A×B",
      chipAdviceLabel: "Data Advice", chipAdviceTitle: "Data advice",
      gridTipsHtml:
        "• Click a cell to toggle (z,ϕ). With <strong>Single‑valued mode</strong>, a click keeps exactly one ϕ in that row (depth).<br/>" +
        "• Un‑check a depth below to <em>restrict the domain</em> (ignored by the function test).",
      actDomainTitle: "Active Domain A (depths in m)",
      panelStateTitle: "State A, B, Range & Units",
      chipADepthText: "A (Depth)",
      chipBPorText: "B (Porosity)",
      chipRangeText: "Range",
      unitsLine: "Units: depth in <strong>m</strong>, porosity in <strong>fraction 0–1</strong>. The grid uses sampled ticks T ⊂ B for interaction.",
      panelCheckTitle: "Relation & Function Checks",
      fnOnActive: "Function on active A?",
      rangeSize: (n)=>`Range size: ${n}`,
      checkBullets: [
        "<strong>Relation:</strong> any set of selected cells R ⊆ A×B.",
        "<strong>Function:</strong> each active depth z has exactly one ϕ (row test here).",
        "<strong>Notation:</strong> ϕ : A → B, ϕ(z); pairs (z,ϕ).",
        "<strong>Cartesian product:</strong> the whole grid is A×T (with T⊂B).",
        "<strong>Data advice:</strong> if a depth has multiple ϕ, clean or restrict the domain before using ϕ(z)."
      ],
      MTitle: "Measurements M (given)",
      MheadDepth: "depth m",
      MheadPhi: "ϕ",
      RTitle: "Selected Relation R ⊆ A×B",
      RheadHash: "#",
      RheadZ: "z",
      RheadArrow: "→",
      RheadPhi: "ϕ",
      toastSaved: "Saved to ",
      narrativeTitle: "Concept Narrative",
      narrativeIntro: "Click any concept chip above (Domain, Codomain, Range, …) to highlight it on the grid and read the explanation here.",
      axisX: "x: B (Porosity ϕ) — columns",
      axisY: "y: A (Depth m) — rows",
      concepts: {
        domain:   {title:"Domain (A)",           body:"Rows (y‑axis): allowed inputs (depth in meters). Use the checkboxes to restrict A."},
        codomain: {title:"Codomain (B)",         body:"Columns (x‑axis): allowed output type (porosity 0–1). The grid shows sampled ticks T ⊂ B."},
        range:    {title:"Range (Im ϕ)",         body:"Columns that are actually used by selected pairs. The range is a subset of B."},
        relation: {title:"Relation R ⊆ A×B",     body:"Any set of ordered pairs — here, the selected cells on the grid."},
        function: {title:"Function test",        body:"Each active depth row must have exactly one selected cell (row‑based vertical‑line idea)."},
        notation: {title:"Notation ϕ : A → B",   body:"Read as “porosity as a function of depth”. We write pairs as (z, ϕ) and values as ϕ(z)."},
        cartesian:{title:"Cartesian product A×B",body:"The entire grid represents A×T with T ⊂ B. Any relation R is a subset of A×B."},
        advice:   {title:"Data advice",          body:"If a depth has multiple ϕ, clean duplicates or restrict A before using ϕ(z)."}
      }
    },
    hu: {
      title: "Relációk és függvények — Porozitás rácsa",
      btnLoadM: "Mérések M betöltése",
      btnClear: "Mind törlése",
      lblSingle: "Egyértékű mód",
      btnSave: "Megoldás mentése (JSON)",
      chipDomainLabel: "Értelmezési tartomány", chipDomainTitle: "Értelmezési tartomány (A) kiemelése",
      chipCodomainLabel: "Célhalmaz",           chipCodomainTitle: "Célhalmaz (B) kiemelése",
      chipRangeLabel: "Képhalmaz",              chipRangeTitle: "Képhalmaz (Im ϕ) kiemelése",
      chipRelationLabel: "Reláció",             chipRelationTitle: "Mi a reláció?",
      chipFunctionLabel: "Függvény",            chipFunctionTitle: "Mikor függvény?",
      chipNotationLabel: "Jelölés",             chipNotationTitle: "Jelölés: ϕ : A → B, ϕ(z)",
      chipCartesianLabel: "A×B",                chipCartesianTitle: "Descartes‑szorzat A×B",
      chipAdviceLabel: "Adattanács",            chipAdviceTitle: "Adattisztítási tanács",
      gridTipsHtml:
        "• Kattints egy cellára a (z,ϕ) pár ki/be kapcsolásához. Az <strong>Egyértékű mód</strong> soronként pontosan egy ϕ‑t tart meg.<br/>" +
        "• Alul a jelölőnégyzetekkel <em>szűkítheted a tartományt</em> (A); ez a függvénytesztet nem befolyásolja.",
      actDomainTitle: "Aktív A tartomány (mélységek m‑ben)",
      panelStateTitle: "A, B, képhalmaz és mértékegységek",
      chipADepthText: "A (mélység)",
      chipBPorText: "B (porozitás)",
      chipRangeText: "Képhalmaz",
      unitsLine: "Mértékegységek: mélység <strong>m</strong>, porozitás <strong>0–1</strong> közötti tört. A rács B mintavételezett részhalmazát (T ⊂ B) mutatja.",
      panelCheckTitle: "Reláció‑ és függvényellenőrzések",
      fnOnActive: "Függvény az aktív A‑n?",
      rangeSize: (n)=>`Képhalmaz mérete: ${n}`,
      checkBullets: [
        "<strong>Reláció:</strong> bármely kiválasztott cellahalmaz, R ⊆ A×B.",
        "<strong>Függvény:</strong> minden aktív sorhoz (mélységhez) pontosan egy ϕ tartozik (sor‑vizsgálat).",
        "<strong>Jelölés:</strong> ϕ : A → B, ϕ(z); párok (z,ϕ).",
        "<strong>Descartes‑szorzat:</strong> a teljes rács A×T (T ⊂ B).",
        "<strong>Adattanács:</strong> ha egy mélységhez több ϕ tartozik, tisztítsd az adatot vagy szűkítsd A‑t, mielőtt ϕ(z)‑t használsz."
      ],
      MTitle: "Mérések M (adott)",
      MheadDepth: "mélység m",
      MheadPhi: "ϕ",
      RTitle: "Kiválasztott reláció R ⊆ A×B",
      RheadHash: "#",
      RheadZ: "z",
      RheadArrow: "→",
      RheadPhi: "ϕ",
      toastSaved: "Elmentve ide: ",
      narrativeTitle: "Fogalmi magyarázat",
      narrativeIntro: "Kattints a fenti fogalmi chipekre (Tartomány, Célhalmaz, Képhalmaz, …), hogy a rácson kiemelve és itt magyarázva lásd.",
      axisX: "x: B (porozitás ϕ) — oszlopok",
      axisY: "y: A (mélység m) — sorok",
      concepts: {
        domain:   {title:"Értelmezési tartomány (A)",      body:"Sorok (y‑tengely): megengedett bemenetek (mélység méterben). A tartományt a lenti jelölőnégyzetekkel szűkítheted."},
        codomain: {title:"Célhalmaz (B)",                  body:"Oszlopok (x‑tengely): megengedett kimenet típusa (porozitás 0–1). A rács a B egy mintavételezett részhalmazát, T‑t mutatja."},
        range:    {title:"Képhalmaz (Im ϕ)",               body:"Azok az oszlopok, amelyeket a kijelölt párok ténylegesen használnak. A képhalmaz B részhalmaza."},
        relation: {title:"Reláció R ⊆ A×B",                body:"Bármely rendezettpár‑halmaz — itt a rácson kijelölt cellák."},
        function: {title:"Függvényteszt",                  body:"Minden aktív mélységsorban pontosan egy kijelölt cella lehet (sor‑alapú teszt)."},
        notation: {title:"Jelölés ϕ : A → B",              body:"Olvasata: „porozitás a mélység függvényében”. A párok (z, ϕ), az érték ϕ(z)."},
        cartesian:{title:"Descartes‑szorzat A×B",          body:"Az egész rács A×T, ahol T ⊂ B. Minden reláció R az A×B részhalmaza."},
        advice:   {title:"Adattanács",                     body:"Ha egy mélységhez több ϕ tartozik, tisztítsd az ismétléseket vagy szűkítsd az A tartományt, mielőtt ϕ(z)‑t használsz."}
      }
    }
  };

  // ---------- DOM ----------
  const $ = (id) => document.getElementById(id);
  const canvas = $("grid");
  const ctx = canvas.getContext("2d");
  const toast = $("toast");

  // ---------- State ----------
  const state = {
    lang: "en",
    A: [],        // depths (rows; y)
    Bticks: [],   // porosity ticks (columns; x)
    M: [],        // given measurement pairs
    units: {depth:"m", phi:"fraction (0–1)"},
    notation: null,

    activeDepth: new Map(),  // depth -> bool
    selection: new Set(),    // "z|phi"
    singleValued: false,

    spotlights: new Set(),   // {'domain','codomain','range','relation','function','notation','cartesian','advice'}

    hover: {row:-1,col:-1},
    axisXText: i18n.en.axisX,
    axisYText: i18n.en.axisY,
  };

  // ---------- Layout ----------
  const margin = {left: 110, right: 20, top: 76, bottom: 28};
  let geom = {cols:0, rows:0, cw:40, ch:32};

  function keyOf(z, phi){ return `${z}|${phi}`; }
  function splitKey(k){ const [z,phi] = k.split("|"); return {z:+z, phi:+phi}; }

  // ---------- Fetch config ----------
  fetch("/api/config").then(r=>r.json()).then(cfg => {
    state.A = cfg.A_depths_m;
    state.Bticks = cfg.B_ticks_phi;
    state.M = cfg.M_pairs;
    state.units = cfg.units;
    state.notation = cfg.notation || null;

    state.A.forEach(z => state.activeDepth.set(z, true));
    buildDomainToggles();
    buildMTable();

    // Wire controls
    $("btnLoadM").addEventListener("click", () => { loadM(); draw(); updatePanels(); updateNarrative(); });
    $("btnClear").addEventListener("click", () => { state.selection.clear(); draw(); updatePanels(); updateNarrative(); });
    $("singleValued").addEventListener("change", (e) => { state.singleValued = e.target.checked; });
    $("btnSave").addEventListener("click", saveJSON);

    // Language selector
    $("langEn").addEventListener("click", () => setLang("en"));
    $("langHu").addEventListener("click", () => setLang("hu"));

    // Concept chips (each toggles independently)
    wireChip("chipDomain",   "domain");
    wireChip("chipCodomain", "codomain");
    wireChip("chipRange",    "range");
    wireChip("chipRelation", "relation");
    wireChip("chipFunction", "function");
    wireChip("chipNotation", "notation");
    wireChip("chipCartesian","cartesian");
    wireChip("chipAdvice",   "advice");

    // Canvas events
    window.addEventListener("resize", resizeCanvas);
    canvas.addEventListener("pointerdown", onClickCell);
    canvas.addEventListener("pointermove", onHover);
    canvas.addEventListener("pointerleave", ()=>{ state.hover={row:-1,col:-1}; draw(); });

    // Initial language
    const stored = localStorage.getItem("lang");
    const initial = stored || (navigator.language && navigator.language.toLowerCase().startsWith("hu") ? "hu" : "en");
    setLang(initial);

    resizeCanvas();
    draw();
    updatePanels();
    updateNarrative(); // initial message
  });

  // ---------- Language ----------
  function setLang(lang){
    state.lang = (lang === "hu") ? "hu" : "en";
    localStorage.setItem("lang", state.lang);
    $("langEn").classList.toggle("active", state.lang === "en");
    $("langHu").classList.toggle("active", state.lang === "hu");
    applyLanguage();
  }

  function applyLanguage(){
    const L = i18n[state.lang];

    // Header & buttons
    $("titleText").textContent = L.title;
    $("btnLoadM").textContent = L.btnLoadM;
    $("btnClear").textContent = L.btnClear;
    $("lblSingle").textContent = L.lblSingle;
    $("btnSave").textContent = L.btnSave;

    // Chips labels + titles
    $("labDomain").textContent = L.chipDomainLabel;
    $("labCodomain").textContent = L.chipCodomainLabel;
    $("labRange").textContent = L.chipRangeLabel;
    $("labRelation").textContent = L.chipRelationLabel;
    $("labFunction").textContent = L.chipFunctionLabel;
    $("labNotation").textContent = L.chipNotationLabel;
    $("labCartesian").textContent = L.chipCartesianLabel;
    $("labAdvice").textContent = L.chipAdviceLabel;

    $("chipDomain").title   = L.chipDomainTitle;
    $("chipCodomain").title = L.chipCodomainTitle;
    $("chipRange").title    = L.chipRangeTitle;
    $("chipRelation").title = L.chipRelationTitle;
    $("chipFunction").title = L.chipFunctionTitle;
    $("chipNotation").title = L.chipNotationTitle;
    $("chipCartesian").title= L.chipCartesianTitle;
    $("chipAdvice").title   = L.chipAdviceTitle;

    // Tips, badges, titles
    $("gridTips").innerHTML = L.gridTipsHtml;
    $("actDomainTitle").textContent = L.actDomainTitle;

    $("panelStateTitle").textContent = L.panelStateTitle;
    $("chipADepthText").textContent = L.chipADepthText;
    $("chipBPorText").textContent = L.chipBPorText;
    $("chipRangeText").textContent = L.chipRangeText;
    $("unitsLine").innerHTML = L.unitsLine;

    $("panelCheckTitle").textContent = L.panelCheckTitle;
    // bullets
    const ul = $("checkBullets");
    ul.innerHTML = "";
    L.checkBullets.forEach(line => {
      const li = document.createElement("li"); li.innerHTML = line; ul.appendChild(li);
    });

    $("MTitle").textContent = L.MTitle;
    $("MheadDepth").textContent = L.MheadDepth;
    $("MheadPhi").textContent = L.MheadPhi;

    $("RTitle").textContent = L.RTitle;
    $("RheadHash").textContent = L.RheadHash;
    $("RheadZ").textContent = L.RheadZ;
    $("RheadArrow").textContent = L.RheadArrow;
    $("RheadPhi").textContent = L.RheadPhi;

    $("narrativeTitle").textContent = L.narrativeTitle;
    $("narrativeIntro").textContent = L.narrativeIntro;

    // Notation (math stays same)
    $("notationText").textContent = "ϕ : A → B, ϕ(z)";

    // Axis labels for canvas
    state.axisXText = L.axisX;
    state.axisYText = L.axisY;

    // Redraw & refresh status
    updatePanels();
    updateNarrative();
    draw();
  }

  // ---------- UI builders ----------
  function buildDomainToggles(){
    const host = $("domainToggles");
    host.innerHTML = "";
    state.A.forEach(z => {
      const lab = document.createElement("label");
      const cb = document.createElement("input");
      cb.type = "checkbox"; cb.checked = true;
      cb.addEventListener("change", () => { state.activeDepth.set(z, cb.checked); draw(); updatePanels(); updateNarrative(); });
      lab.appendChild(cb);
      lab.appendChild(document.createTextNode(` ${z} m`));
      host.appendChild(lab);
    });
  }

  function buildMTable(){
    const tb = $("Mbody");
    tb.innerHTML = "";
    state.M.forEach(p => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.z}</td><td>${p.phi.toFixed(2)}</td>`;
      tb.appendChild(tr);
    });
  }

  function loadM(){
    state.selection.clear();
    for (const p of state.M){
      state.selection.add(keyOf(p.z, p.phi));
    }
  }

  // ---------- Geometry helpers ----------
  function resizeCanvas(){
    const r = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  function computeGeom(){
    const W = canvas.clientWidth, H = canvas.clientHeight;
    const cols = state.Bticks.length;  // x = porosity
    const rows = state.A.length;       // y = depth
    const cw = Math.max(26, Math.floor((W - margin.left - margin.right) / Math.max(1, cols)));
    const ch = Math.max(24, Math.floor((H - margin.top - margin.bottom) / Math.max(1, rows)));
    geom = {cols, rows, cw, ch};
  }

  function colAt(x){
    const cx = x - margin.left;
    if (cx < 0) return -1;
    const col = Math.floor(cx / geom.cw);
    return (col >= 0 && col < geom.cols) ? col : -1;
  }
  function rowAt(y){
    const ry = y - margin.top;
    if (ry < 0) return -1;
    const row = Math.floor(ry / geom.ch);
    return (row >= 0 && row < geom.rows) ? row : -1;
  }

  // ---------- Selection logic ----------
  function countInRow(z){
    let k = 0;
    for (const kk of state.selection){
      const s = splitKey(kk);
      if (s.z === z) k++;
    }
    return k;
  }

  function isFunctionOnActiveDomain(){
    for (const z of state.A){
      if (!state.activeDepth.get(z)) continue;
      if (countInRow(z) !== 1) return false;
    }
    return true;
  }

  function rangeSet(){
    const seen = new Set();
    for (const kk of state.selection){
      const {z, phi} = splitKey(kk);
      if (!state.activeDepth.get(z)) continue;
      seen.add(phi);
    }
    return Array.from(seen).sort((a,b)=>a-b);
  }

  // ---------- Canvas interaction ----------
  function onClickCell(ev){
    const r = canvas.getBoundingClientRect();
    const x = ev.clientX - r.left, y = ev.clientY - r.top;
    const col = colAt(x), row = rowAt(y);
    if (col < 0 || row < 0) return;

    const z = state.A[row];
    const phi = state.Bticks[col];
    const k = keyOf(z, phi);

    if (state.singleValued){
      for (const kk of Array.from(state.selection)){
        const s = splitKey(kk);
        if (s.z === z) state.selection.delete(kk);
      }
      state.selection.add(k);
    } else {
      if (state.selection.has(k)) state.selection.delete(k);
      else state.selection.add(k);
    }

    draw();
    updatePanels();
    updateNarrative();
  }

  function onHover(ev){
    const r = canvas.getBoundingClientRect();
    const x = ev.clientX - r.left, y = ev.clientY - r.top;
    state.hover = {row: rowAt(y), col: colAt(x)};
    draw();
  }

  // ---------- Concept chips ----------
  function wireChip(elId, kind){
    const el = $(elId);
    el.addEventListener("click", () => {
      if (state.spotlights.has(kind)) state.spotlights.delete(kind);
      else state.spotlights.add(kind);
      el.classList.toggle("active", state.spotlights.has(kind));
      draw();
      updateNarrative();
    });
  }

  // ---------- Narrative (below stage) ----------
  function updateNarrative(){
    const list = $("narrativeItems");
    const intro = $("narrativeIntro");
    const Lc = i18n[state.lang].concepts;

    list.innerHTML = "";
    if (state.spotlights.size === 0){
      intro.style.display = "block";
      return;
    }
    intro.style.display = "none";

    const order = ["domain","codomain","range","relation","function","notation","cartesian","advice"];
    order.forEach(k => {
      if (!state.spotlights.has(k)) return;
      const {title, body} = Lc[k];
      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `<h3>${title}</h3><p>${body}</p>`;
      list.appendChild(div);
    });
  }

  // ---------- Drawing ----------
  function draw(){
    computeGeom();
    const W = canvas.clientWidth, H = canvas.clientHeight;
    ctx.clearRect(0,0,W,H);

    // Frame
    ctx.fillStyle = "#0c1220";
    ctx.strokeStyle = "#223045";
    ctx.lineWidth = 1.5;
    roundRect(8.5,8.5,W-17,H-17,12); ctx.fill(); ctx.stroke();

    // Axis titles
    ctx.fillStyle = "#a7bfdf";
    ctx.font = "600 14px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.textAlign = "left"; ctx.textBaseline = "alphabetic";
    ctx.fillText(state.axisXText, margin.left, 24);
    ctx.fillText(state.axisYText, margin.left, 42);

    // Column headers (ϕ) + range tint
    ctx.textAlign = "center"; ctx.textBaseline = "alphabetic";
    const Rset = new Set(rangeSet());
    for (let c=0; c<geom.cols; c++){
      const phi = state.Bticks[c];
      const xmid = margin.left + c*geom.cw + geom.cw/2;
      const used = Rset.has(phi);
      if (used){
        ctx.fillStyle = "rgba(52,211,153,0.15)";
        ctx.fillRect(margin.left + c*geom.cw, margin.top-22, geom.cw, 20);
      }
      ctx.fillStyle = "#cfe0ff";
      ctx.font = "600 12px system-ui,-apple-system,Segoe UI,Roboto,Arial";
      ctx.fillText(phi.toFixed(2), xmid, margin.top - 6);
    }

    // Row labels (z) + row function counters
    ctx.textAlign = "right"; ctx.textBaseline = "middle";
    for (let r=0; r<geom.rows; r++){
      const z = state.A[r];
      const ymid = margin.top + r*geom.ch + geom.ch/2;
      const count = countInRow(z);
      const active = state.activeDepth.get(z);

      ctx.fillStyle = "#cfe0ff";
      ctx.font = "600 12px system-ui,-apple-system,Segoe UI,Roboto,Arial";
      ctx.fillText(`${z}`, margin.left - 10, ymid);

      let lab = "–", color = "#b7c8e4";
      if (active){
        if (count === 1){ lab = "1"; color = "#34d399"; }
        else if (count === 0){ lab = "0"; color = "#fbbf24"; }
        else { lab = String(count); color = "#f87171"; }
      } else {
        lab = "×"; color = "#95a3b8";
      }
      ctx.fillStyle = color;
      ctx.textAlign = "left";
      ctx.fillText(lab, margin.left + geom.cols*geom.cw + 8, ymid);
      ctx.textAlign = "right";
    }

    // Shade restricted rows
    for (let r=0; r<geom.rows; r++){
      const z = state.A[r];
      if (!state.activeDepth.get(z)){
        ctx.fillStyle = "rgba(255,255,255,0.04)";
        ctx.fillRect(margin.left, margin.top + r*geom.ch, geom.cols*geom.cw, geom.ch);
      }
    }

    // Hover row/col helpers
    if (state.hover.row >= 0){
      ctx.fillStyle = "rgba(124,177,255,0.08)";
      ctx.fillRect(margin.left, margin.top + state.hover.row*geom.ch, geom.cols*geom.cw, geom.ch);
    }
    if (state.hover.col >= 0){
      ctx.fillStyle = "rgba(124,177,255,0.08)";
      ctx.fillRect(margin.left + state.hover.col*geom.cw, margin.top, geom.cw, geom.rows*geom.ch);
    }

    // Grid lines
    ctx.strokeStyle = "#223045"; ctx.lineWidth = 1;
    for (let c=0; c<=geom.cols; c++){
      const x = margin.left + c*geom.cw;
      ctx.beginPath(); ctx.moveTo(x, margin.top); ctx.lineTo(x, margin.top + geom.rows*geom.ch); ctx.stroke();
    }
    for (let r=0; r<=geom.rows; r++){
      const y = margin.top + r*geom.ch;
      ctx.beginPath(); ctx.moveTo(margin.left, y); ctx.lineTo(margin.left + geom.cols*geom.cw, y); ctx.stroke();
    }

    // Selections
    for (const k of state.selection){
      const {z, phi} = splitKey(k);
      const r = state.A.indexOf(z), c = state.Bticks.indexOf(phi);
      if (r < 0 || c < 0) continue;
      const x = margin.left + c*geom.cw;
      const y = margin.top  + r*geom.ch;
      const active = state.activeDepth.get(z);
      ctx.fillStyle = active ? "rgba(124,177,255,0.85)" : "rgba(124,177,255,0.35)";
      ctx.fillRect(x+2, y+2, geom.cw-4, geom.ch-4);

      ctx.beginPath();
      ctx.arc(x + geom.cw/2, y + geom.ch/2, Math.min(geom.cw,geom.ch)*0.18, 0, Math.PI*2);
      ctx.closePath();
      ctx.fillStyle = active ? "#7cb1ff" : "#7cb1ff88";
      ctx.fill();
      ctx.strokeStyle = "#cfe0ff22"; ctx.lineWidth = 1; ctx.stroke();
    }

    // Spotlights (union of all active concepts)
    if (state.spotlights.size > 0){
      applySpotlights();
    }
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }

  function applySpotlights(){
    const W = canvas.clientWidth, H = canvas.clientHeight;

    // Dim background
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // Carve highlighted regions
    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    const cutRect = (x,y,w,h) => { ctx.fillStyle="#000"; ctx.fillRect(x,y,w,h); };

    const carveDomain = () => {
      for (let r=0;r<geom.rows;r++){
        cutRect(margin.left, margin.top + r*geom.ch, geom.cols*geom.cw, geom.ch);
      }
      cutRect(8, margin.top, margin.left-12, geom.rows*geom.ch);
    };
    const carveCodomain = () => {
      for (let c=0;c<geom.cols;c++){
        cutRect(margin.left + c*geom.cw, margin.top, geom.cw, geom.rows*geom.ch);
      }
      cutRect(margin.left, margin.top-24, geom.cols*geom.cw, 24);
    };
    const carveRange = () => {
      const R = new Set(rangeSet());
      for (let c=0;c<geom.cols;c++){
        const phi = state.Bticks[c];
        if (R.has(phi)){
          cutRect(margin.left + c*geom.cw, margin.top-24, geom.cw, 24 + geom.rows*geom.ch);
        }
      }
    };
    const carveRelation = () => {
      for (const k of state.selection){
        const {z, phi} = splitKey(k);
        const r = state.A.indexOf(z), c = state.Bticks.indexOf(phi);
        if (r<0||c<0) continue;
        cutRect(margin.left + c*geom.cw + 2, margin.top + r*geom.ch + 2, geom.cw-4, geom.ch-4);
      }
    };
    const carveFunction = () => {
      for (let r=0;r<geom.rows;r++){
        cutRect(margin.left, margin.top + r*geom.ch, geom.cols*geom.cw, geom.ch);
      }
      cutRect(margin.left + geom.cols*geom.cw, margin.top, 60, geom.rows*geom.ch);
    };
    const carveNotation = () => {
      cutRect(margin.left, 12, Math.min(380, geom.cols*geom.cw), 40);
    };
    const carveCartesian = () => {
      cutRect(margin.left, margin.top, geom.cols*geom.cw, geom.rows*geom.ch);
    };
    const carveAdvice = () => {
      for (let r=0;r<geom.rows;r++){
        const z = state.A[r];
        const active = state.activeDepth.get(z);
        const k = countInRow(z);
        if (!active || k !== 1){
          cutRect(margin.left, margin.top + r*geom.ch, geom.cols*geom.cw, geom.ch);
        }
      }
    };

    const S = state.spotlights;
    if (S.has("domain"))   carveDomain();
    if (S.has("codomain")) carveCodomain();
    if (S.has("range"))    carveRange();
    if (S.has("relation")) carveRelation();
    if (S.has("function")) carveFunction();
    if (S.has("notation")) carveNotation();
    if (S.has("cartesian")) carveCartesian();
    if (S.has("advice"))   carveAdvice();

    ctx.restore();

    // Subtle glow
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(255,213,74,0.30)";
    if (S.has("domain")){
      for (let r=0;r<geom.rows;r++){
        ctx.fillRect(margin.left, margin.top + r*geom.ch, geom.cols*geom.cw, geom.ch);
      }
    }
    if (S.has("codomain")){
      for (let c=0;c<geom.cols;c++){
        ctx.fillRect(margin.left + c*geom.cw, margin.top, geom.cw, geom.rows*geom.ch);
      }
    }
    if (S.has("range")){
      const R = new Set(rangeSet());
      for (let c=0;c<geom.cols;c++){
        const phi = state.Bticks[c];
        if (R.has(phi)){
          ctx.fillRect(margin.left + c*geom.cw, margin.top-24, geom.cw, 24 + geom.rows*geom.ch);
        }
      }
    }
    if (S.has("relation")){
      for (const k of state.selection){
        const {z, phi} = splitKey(k);
        const r = state.A.indexOf(z), c = state.Bticks.indexOf(phi);
        if (r<0||c<0) continue;
        ctx.fillRect(margin.left + c*geom.cw + 2, margin.top + r*geom.ch + 2, geom.cw-4, geom.ch-4);
      }
    }
    if (S.has("function")){
      for (let r=0;r<geom.rows;r++){
        ctx.fillRect(margin.left, margin.top + r*geom.ch, geom.cols*geom.cw, geom.ch);
      }
    }
    if (S.has("notation")){
      ctx.fillRect(margin.left, 12, Math.min(380, geom.cols*geom.cw), 40);
    }
    if (S.has("cartesian")){
      ctx.fillRect(margin.left, margin.top, geom.cols*geom.cw, geom.rows*geom.ch);
    }
    if (S.has("advice")){
      for (let r=0;r<geom.rows;r++){
        const z = state.A[r];
        const active = state.activeDepth.get(z);
        const k = countInRow(z);
        if (!active || k !== 1){
          ctx.fillRect(margin.left, margin.top + r*geom.ch, geom.cols*geom.cw, geom.ch);
        }
      }
    }
    ctx.restore();
  }

  // ---------- Panels & tables ----------
  function updatePanels(){
    const Aactive = state.A.filter(z => state.activeDepth.get(z));
    $("Aset").textContent = `{${Aactive.join(", ")}}`;

    const R = rangeSet();
    $("Range").textContent = `{${R.map(v=>v.toFixed(2)).join(", ")}}`;
    $("rangeCount").textContent = i18n[state.lang].rangeSize(R.length);

    // Progress
    let ok = 0, total = 0;
    for (const z of state.A){
      if (!state.activeDepth.get(z)) continue;
      total++;
      if (countInRow(z) === 1) ok++;
    }
    const pct = total ? Math.round(100*ok/total) : 0;
    $("scoreFill").style.width = `${pct}%`;

    const isFn = isFunctionOnActiveDomain();
    $("fnText").innerHTML = `${i18n[state.lang].fnOnActive} ${isFn ? '<span class="ok">✓</span>' : '<span class="bad">✗</span>'}`;

    // Relation table
    const body = $("Rbody");
    body.innerHTML = "";
    const pairs = Array.from(state.selection).map(splitKey)
                       .filter(p => state.activeDepth.get(p.z))
                       .sort((a,b)=> (a.z-b.z) || (a.phi-b.phi));
    pairs.forEach((p,i) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="k">${i+1}</td><td>${p.z}</td><td class="k">→</td><td>${p.phi.toFixed(2)}</td>`;
      body.appendChild(tr);
    });
  }

  // ---------- Save (download JSON) ----------
  function saveJSON(){
    const data = {
      language: state.lang,
      A_active: state.A.filter(z => state.activeDepth.get(z)),
      ticks_B: state.Bticks,
      relation_R: Array.from(state.selection).map(splitKey).sort((a,b)=> (a.z-b.z) || (a.phi-b.phi)),
      range: rangeSet(),
      function_on_active_A: isFunctionOnActiveDomain(),
      units: state.units,
      notation: state.notation
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "relation.json";
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=> URL.revokeObjectURL(url), 500);
    // toast
    toast.innerHTML = (i18n[state.lang].toastSaved || "Saved to ") + `<span class="mono">relation.json</span>`;
    toast.style.display = "block";
    setTimeout(()=> toast.style.display = "none", 1500);
  }

  // ---------- Helpers ----------
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }
})();
</script>
</body>
</html>
