{% extends "index.html" %}
{% block page_title %}Relations & Functions — Single View Game{% endblock %}

{% block controls %}
<div class="controls" aria-label="Game controls" style="flex-wrap:wrap; gap:8px;">
  <!-- LAYERS -->
  <div id="layerChips" class="chips" style="flex-wrap:wrap; gap:6px;"></div>

  <!-- EDIT MODES -->
  <div id="editChips" class="chips" style="flex-wrap:wrap; gap:6px;"></div>

  <!-- Quick presets for B↔B properties -->
  <div id="propPreset" class="chips" style="flex-wrap:wrap; gap:6px;"></div>

  <!-- Utilities -->
  <button id="btnReset" class="btn">Reset</button>
  <label class="switch btn"><input id="lockNodes" type="checkbox" /><span id="txtLock">Lock nodes</span></label>
  <label class="switch btn"><input id="showLabels" type="checkbox" checked /><span id="txtShow">Show labels</span></label>
  <!-- Language toggle beside Show labels -->
  <div class="chips" style="display:inline-flex; gap:6px;">
    <div id="langEN" class="chip" title="English">ENG</div>
    <div id="langHU" class="chip" title="Magyar">HUN</div>
  </div>
</div>
{% endblock %}

{% block content %}
<section class="canvas-card" aria-label="Single canvas">
  <canvas id="stage" role="img" aria-label="Relations & Functions canvas"></canvas>
</section>

<aside>
  <div class="sets-top">
    <div class="badge" id="datasetLabel">Dataset: <strong>A (circles) • B (squares) • C (diamonds)</strong></div>

    <!-- Score block -->
    <div class="score" aria-live="polite">
      <span id="scoreText">Score: 0/8 (0%)</span>
      <div class="bar"><div id="scoreFill" class="fill"></div></div>
    </div>

    <div class="tips">
      <div class="pill" id="tipWord">Tip</div>
      <div id="tipLine1">Pick an <b>Edit</b> mode, then click <i>source → target</i> to (un)link.</div>
      <div id="tipLine2">Use <b>Layers</b> to show/hide R, f, g, g∘f, B‑relation, A‑equivalence.</div>
    </div>
  </div>

  <div class="summary">
    <h2 id="checksHdr">Live Checks (8 core ideas)</h2>

    <div class="row"><div class="lhs"><strong id="c1Title">1) Binary Relation R ⊆ A×B</strong></div><div class="k" id="c1Val">R pairs: 0</div></div>
    <div class="row"><div class="lhs"><strong id="c2Title">2) Property (B↔B): Reflexive</strong></div><div class="k" id="c2Val">—</div></div>
    <div class="row"><div class="lhs"><strong id="c3Title">3) Equivalence (A↔A): reflexive, symmetric, transitive</strong></div><div class="k" id="c3Val">—</div></div>
    <div class="row"><div class="lhs"><strong id="c4Title">4) Partial Order (B↔B): reflexive, antisymmetric, transitive</strong></div><div class="k" id="c4Val">—</div></div>
    <div class="row"><div class="lhs"><strong id="c5Title">5) Function f: A→B (total)</strong></div><div class="k" id="c5Val">—</div></div>
    <div class="row"><div class="lhs"><strong id="c6Title">6) Types for f: injective / surjective / bijective</strong></div><div class="k" id="c6Val">—</div></div>
    <div class="row"><div class="lhs"><strong id="c7Title">7) Composition g∘f: A→C (f and g total)</strong></div><div class="k" id="c7Val">—</div></div>
    <div class="row"><div class="lhs"><strong id="c8Title">8) Inverse f⁻¹ exists (f bijective)</strong></div><div class="k" id="c8Val">—</div></div>
  </div>
</aside>

<section class="explain-card" aria-live="polite">
  <div class="explain-head">
    <span class="badge" id="narrHdr">Narrative</span>
  </div>
  <div id="narrative" class="explain-body">
    Build examples that satisfy each idea. Your moves are checked live, and the score updates automatically.
  </div>
</section>
{% endblock %}

{% block scripts %}
<script>
(() => {
  // ---------- Utilities & constants ----------
  const $ = id => document.getElementById(id);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist = (x1,y1,x2,y2) => Math.hypot(x1-x2, y1-y2);
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  const COL = {
    frame:"#0c1220", border:"#223045",
    A:"#7aa2ff", B:"#60a5fa", C:"#f59e0b",
    R:"#58c6ff", f:"#34d399", g:"#f59e0b", comp:"#facc15",
    RB:"#a78bfa", RA:"#f472b6"
  };

  // Language pack (UI + narrative)
  const L = {
    en: {
      layers:"Layers", edit:"Edit",
      layer_R:"Show R", layer_f:"Show f", layer_g:"Show g", layer_comp:"Show g∘f",
      layer_RB:"Show B‑relation", layer_RA:"Show A‑equivalence",
      edit_none:"Move only", edit_R:"Edit R (A→B)", edit_f:"Edit f (A→B)",
      edit_g:"Edit g (B→C)", edit_RB:"Edit B↔B", edit_RA:"Edit A↔A",
      preset:"B‑relation presets", p_identity:"Identity", p_adjacent:"Adjacent", p_chain:"≤ chain",
      reset:"Reset", lock:"Lock nodes", show:"Show labels",
      dataset:"Dataset",
      tip:"Tip",
      tip1:"Pick an Edit mode, then click source → target to toggle an arrow.",
      tip2:"Use Layers to show/hide R, f, g, g∘f, B‑relation, A‑equivalence.",
      checks:"Live Checks (8 core ideas)",
      c1:"1) Binary Relation R ⊆ A×B",
      c2:"2) Property (B↔B): Reflexive",
      c3:"3) Equivalence (A↔A): reflexive, symmetric, transitive",
      c4:"4) Partial Order (B↔B): reflexive, antisymmetric, transitive",
      c5:"5) Function f: A→B (total)",
      c6:"6) Types for f: injective / surjective / bijective",
      c7:"7) Composition g∘f: A→C (f and g total)",
      c8:"8) Inverse f⁻¹ exists (f bijective)",
      narr:"Narrative",
      // Narrative messages
      g1_need:"Add at least 4 pairs to R in 'Edit R' mode (A→B).",
      g1_ok:"Good! R has ≥4 pairs — a concrete binary relation example.",
      g2_need:"Make B‑relation reflexive: ensure (b,b) for every b.",
      g2_ok:"Nice — B‑relation is reflexive.",
      g3_need:"Make A‑equivalence reflexive, symmetric, and transitive (loops + two‑way links).",
      g3_ok:"Great! A‑equivalence satisfies all three properties.",
      g4_need:"Turn B‑relation into a partial order (reflexive + antisymmetric + transitive).",
      g4_ok:"Excellent — B‑relation is a partial order.",
      g5_need:"Make f a total function: each a∈A has exactly one outgoing arrow to B.",
      g5_ok:"f is a function A→B (total).",
      g6_need:"Make f injective or surjective (or both).",
      g6_ok_inj:"f is injective.",
      g6_ok_surj:"f is surjective.",
      g6_ok_bij:"f is bijective.",
      g7_need:"Make both f and g total (one arrow from each A and each B).",
      g7_ok:"g∘f is well‑defined (both f and g are total).",
      g8_need:"Make f bijective to guarantee an inverse.",
      g8_ok:"f is bijective — f⁻¹ exists.",
    },
    hu: {
      layers:"Rétegek", edit:"Szerkesztés",
      layer_R:"R mutatása", layer_f:"f mutatása", layer_g:"g mutatása", layer_comp:"g∘f mutatása",
      layer_RB:"B‑reláció mutatása", layer_RA:"A‑ekvivalencia mutatása",
      edit_none:"Csak mozgatás", edit_R:"R szerk. (A→B)", edit_f:"f szerk. (A→B)",
      edit_g:"g szerk. (B→C)", edit_RB:"B↔B szerk.", edit_RA:"A↔A szerk.",
      preset:"B‑reláció sablonok", p_identity:"Identitás", p_adjacent:"Szomszédos", p_chain:"≤ lánc",
      reset:"Visszaállítás", lock:"Objektumok zárolása", show:"Címkék mutatása",
      dataset:"Adatkészlet",
      tip:"Tipp",
      tip1:"Válassz szerkesztési módot, majd kattints forrás → cél a nyíl (ki/be) kapcsolásához.",
      tip2:"A Rétegek kapcsolóival rejtsd/mutasd az R, f, g, g∘f, B‑reláció, A‑ekvivalencia elemeket.",
      checks:"Élő ellenőrzések (8 alapötlet)",
      c1:"1) Bináris reláció R ⊆ A×B",
      c2:"2) Tulajdonság (B↔B): reflexív",
      c3:"3) Ekvivalencia (A↔A): reflexív, szimmetrikus, tranzitív",
      c4:"4) Részbenrendezés (B↔B): reflexív, antiszimmetrikus, tranzitív",
      c5:"5) Függvény f: A→B (teljes)",
      c6:"6) f típusai: injektív / szürjektív / bijektív",
      c7:"7) Összetétel g∘f: A→C (f és g teljes)",
      c8:"8) Inverz f⁻¹ létezik (f bijektív)",
      narr:"Magyarázat",
      // Narrative messages
      g1_need:"Adj legalább 4 párt R‑hez az „R szerk.” módban (A→B).",
      g1_ok:"Szuper! R ≥4 pár — konkrét bináris reláció.",
      g2_need:"Tedd a B‑relációt reflexívvé: minden b‑re legyen (b,b).",
      g2_ok:"Rendben — B‑reláció reflexív.",
      g3_need:"Tedd az A‑ekvivalenciát reflexívvé, szimmetrikussá és tranzitívvá (hurkok + kétirányú élek).",
      g3_ok:"Nagyszerű! A‑ekvivalencia mindhárom tulajdonságot teljesíti.",
      g4_need:"Alakítsd a B‑relációt részbenrendezéssé (reflexív + antiszimmetrikus + tranzitív).",
      g4_ok:"Kiváló — B‑reláció részbenrendezés.",
      g5_need:"Legyen f teljes függvény: minden a∈A pontosan egy B‑hez mutasson.",
      g5_ok:"f teljes függvény A→B.",
      g6_need:"Tedd f‑et injektívvá vagy szürjektívvé (vagy mindkettő).",
      g6_ok_inj:"f injektív.",
      g6_ok_surj:"f szürjektív.",
      g6_ok_bij:"f bijektív.",
      g7_need:"Legyen mind f, mind g teljes (minden A‑ból és B‑ből pontosan egy nyíl).",
      g7_ok:"g∘f jól definiált (f és g teljes).",
      g8_need:"Legyen f bijektív, hogy létezzen inverz.",
      g8_ok:"f bijektív — f⁻¹ létezik.",
    }
  };

  // ---------- State ----------
  const canvas = $("stage");
  const ctx = canvas.getContext("2d");
  const state = {
    lang: localStorage.getItem("relations.lang") || "en",
    assets: null,
    nodes: [],           // {id,type:'A'|'B'|'C', name, x,y,w,h, order?}
    R: [],               // A->B general relation
    F: [],               // f: A->B (function attempt)
    G: [],               // g: B->C (function attempt)
    RB: [],              // B↔B relation
    RA: [],              // A↔A relation (equivalence attempt)
    layers: {R:true,f:true,g:true,comp:true,RB:true,RA:true},
    edit: "none",        // 'none'|'R'|'f'|'g'|'RB'|'RA'
    pending: null,       // {id, type}
    needsDraw: true
  };

  // ---------- Boot / assets ----------
  async function loadAssets(){
    const res = await fetch("/relations/api/assets");
    state.assets = await res.json();
    // Build nodes
    state.nodes = [];
    const rows = [0.22,0.42,0.62,0.82];
    state.assets.A.forEach((a,i)=> state.nodes.push({id:a.id, name:a.name, type:"A", x:0.18, y:rows[i], w:56, h:56}));
    state.assets.B.forEach((b,i)=> state.nodes.push({id:b.id, name:b.name, type:"B", x:0.50, y:rows[3-i], w:88, h:34, order:b.order}));
    state.assets.C.forEach((c,i)=> state.nodes.push({id:c.id, name:c.name, type:"C", x:0.82, y:rows[i], w:88, h:34}));
    // Defaults
    state.R = state.assets.defaults.R_pairs.map(([a,b])=>({from:a,to:b}));
    state.F = state.assets.defaults.f_pairs.map(([a,b])=>({from:a,to:b}));
    state.G = state.assets.defaults.g_pairs.map(([b,c])=>({from:b,to:c}));
    state.RB = state.assets.defaults.B_relations.adjacent.map(([a,b])=>({from:a,to:b}));
    state.RA = state.assets.defaults.A_equiv.map(([a,b])=>({from:a,to:b}));
  }

  // ---------- Layout ----------
  function resizeCanvas(){
    const r = canvas.getBoundingClientRect();
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    state.needsDraw = true;
  }
  window.addEventListener("resize", resizeCanvas);

  // ---------- Node helpers ----------
  function nodeById(id){ return state.nodes.find(n=>n.id===id); }
  function pickNode(px,py){
    for (let i=state.nodes.length-1;i>=0;i--){
      const n = state.nodes[i];
      const x = n.x*canvas.clientWidth, y = n.y*canvas.clientHeight;
      if (n.type==="A"){
        if (dist(px,py,x,y) <= n.w/2) return n;
      } else if (n.type==="B"){
        if (px>=x-n.w/2 && px<=x+n.w/2 && py>=y-n.h/2 && py<=y+n.h/2) return n;
      } else {
        // diamond
        const dx = Math.abs(px - x), dy = Math.abs(py - y);
        if (dx + dy <= n.w*0.6) return n;
      }
    }
    return null;
  }

  // ---------- UI builders ----------
  function makeChip(text, selected, onClick){
    const d = document.createElement("div");
    d.className = "chip";
    d.textContent = text;
    if (selected) d.classList.add("selected");
    d.onclick = onClick;
    return d;
  }
  function addLabelChip(parent, text){
    const s = document.createElement("span");
    s.className = "pill";
    s.textContent = text;
    parent.appendChild(s);
  }
  function buildTopUI(){
    const T = L[state.lang];

    // Layers
    const layers = $("layerChips"); layers.innerHTML = "";
    addLabelChip(layers, T.layers);
    const layerList = [
      ["R","layer_R"],["f","layer_f"],["g","layer_g"],["comp","layer_comp"],
      ["RB","layer_RB"],["RA","layer_RA"]
    ];
    layerList.forEach(([k, lab])=>{
      const chip = makeChip(T[lab], state.layers[k], ()=>{
        state.layers[k] = !state.layers[k];
        chip.classList.toggle("selected", state.layers[k]);
        state.needsDraw = true;
      });
      layers.appendChild(chip);
    });

    // Edit modes
    const edits = $("editChips"); edits.innerHTML = "";
    addLabelChip(edits, T.edit);
    const editList = [
      ["none","edit_none"],["R","edit_R"],["f","edit_f"],
      ["g","edit_g"],["RB","edit_RB"],["RA","edit_RA"]
    ];
    editList.forEach(([k, lab])=>{
      const chip = makeChip(T[lab], state.edit===k, ()=>{
        state.edit = k;
        [...edits.querySelectorAll(".chip")].forEach(c=>c.classList.remove("selected"));
        chip.classList.add("selected");
        state.pending = null;
      });
      edits.appendChild(chip);
    });

    // Presets for B relation
    const preset = $("propPreset"); preset.innerHTML = "";
    addLabelChip(preset, T.preset);
    const pdefs = [
      ["identity","p_identity"],
      ["adjacent","p_adjacent"],
      ["chain_leq","p_chain"]
    ];
    pdefs.forEach(([key, lab])=>{
      const chip = makeChip(T[lab], false, ()=>{
        const pairs = state.assets.defaults.B_relations[key];
        state.RB = pairs.map(([a,b])=>({from:a,to:b}));
        updateAll();
      });
      preset.appendChild(chip);
    });

    // Utility labels
    $("btnReset").textContent = T.reset;
    $("txtLock").textContent = T.lock;
    $("txtShow").textContent = T.show;
    $("datasetLabel").innerHTML = (state.lang==='hu' ? `${T.dataset}: <strong>A (kör) • B (négyzet) • C (rombusz)</strong>`
                                                   : `${T.dataset}: <strong>A (circles) • B (squares) • C (diamonds)</strong>`);
    $("tipWord").textContent = T.tip;
    $("tipLine1").textContent = T.tip1;
    $("tipLine2").textContent = T.tip2;

    // Active language chips
    $("langEN").classList.toggle("selected", state.lang==='en');
    $("langHU").classList.toggle("selected", state.lang==='hu');

    // Check headers
    $("checksHdr").textContent = T.checks;
    $("c1Title").textContent = T.c1; $("c2Title").textContent = T.c2;
    $("c3Title").textContent = T.c3; $("c4Title").textContent = T.c4;
    $("c5Title").textContent = T.c5; $("c6Title").textContent = T.c6;
    $("c7Title").textContent = T.c7; $("c8Title").textContent = T.c8;
    $("narrHdr").textContent = T.narr;
  }

  // ---------- Language toggle ----------
  $("langEN").onclick = ()=>{ state.lang="en"; localStorage.setItem("relations.lang","en"); buildTopUI(); updateAll(); };
  $("langHU").onclick = ()=>{ state.lang="hu"; localStorage.setItem("relations.lang","hu"); buildTopUI(); updateAll(); };

  // ---------- Edge toggling ----------
  function toggleIn(list, a, b, uniqueFrom=false){
    if (uniqueFrom){
      for (let i=list.length-1;i>=0;--i) if (list[i].from===a) list.splice(i,1);
      list.push({from:a,to:b});
      return;
    }
    const idx = list.findIndex(e=>e.from===a && e.to===b);
    if (idx>=0) list.splice(idx,1); else list.push({from:a,to:b});
  }

  // ---------- Interaction ----------
  let drag = null;
  canvas.addEventListener("pointerdown", (ev)=>{
    const r = canvas.getBoundingClientRect();
    const x = ev.clientX - r.left, y = ev.clientY - r.top;
    const n = pickNode(x,y);
    if (!n){ state.pending=null; return; }

    // Edge building per edit mode
    if (state.edit !== "none"){
      if (!state.pending){ state.pending = n; return; }
      const a = state.pending, b = n;
      const done = () => { state.pending=null; updateAll(); };
      if (state.edit==="R"  && a.type==="A" && b.type==="B"){ toggleIn(state.R, a.id,b.id,false); return done(); }
      if (state.edit==="f"  && a.type==="A" && b.type==="B"){ toggleIn(state.F, a.id,b.id,true);  return done(); }
      if (state.edit==="g"  && a.type==="B" && b.type==="C"){ toggleIn(state.G, a.id,b.id,true);  return done(); }
      if (state.edit==="RB" && a.type==="B" && b.type==="B"){ toggleIn(state.RB, a.id,b.id,false); return done(); }
      if (state.edit==="RA" && a.type==="A" && b.type==="A"){ toggleIn(state.RA, a.id,b.id,false); return done(); }
      state.pending=null; // invalid pair
      return;
    }

    // Dragging
    if ($("lockNodes").checked) return;
    drag = { id:n.id, dx:n.x*canvas.clientWidth - x, dy:n.y*canvas.clientHeight - y };
  });
  window.addEventListener("pointermove", (ev)=>{
    if (!drag) return;
    const r = canvas.getBoundingClientRect();
    const x = ev.clientX - r.left, y = ev.clientY - r.top;
    const n = nodeById(drag.id); if (!n) return;
    n.x = clamp((x + drag.dx)/canvas.clientWidth, 0.06, 0.94);
    n.y = clamp((y + drag.dy)/canvas.clientHeight, 0.08, 0.92);
    state.needsDraw = true;
  });
  window.addEventListener("pointerup", ()=> drag=null);

  // ---------- Checks & scoring ----------
  const has = (pairs,a,b) => pairs.some(e=>e.from===a && e.to===b);
  function idsOf(type){ return state.nodes.filter(n=>n.type===type).map(n=>n.id); }

  function isReflexive(ids, pairs){ return ids.every(x => has(pairs,x,x)); }
  function isSymmetric(ids, pairs){ return pairs.every(e => has(pairs,e.to,e.from)); }
  function isAntisymmetric(ids, pairs){ return pairs.every(e => (e.from===e.to) || !has(pairs, e.to, e.from)); }
  function isTransitive(ids, pairs){
    for (const e1 of pairs){
      for (const e2 of pairs){
        if (e1.to === e2.from && !has(pairs, e1.from, e2.to)) return false;
      }
    }
    return true;
  }

  function isFunction(fromIds, toIds, list){
    // total: exactly one outgoing for each fromId, and to must be in toIds
    const out = new Map(fromIds.map(id=>[id,0]));
    for (const e of list){
      if (!fromIds.includes(e.from) || !toIds.includes(e.to)) return false;
      out.set(e.from, (out.get(e.from)||0) + 1);
    }
    return fromIds.every(id => (out.get(id)||0) === 1);
  }
  function isInjective(fromIds, toIds, list){
    const inc = new Map(toIds.map(id=>[id,0]));
    list.forEach(e => inc.set(e.to,(inc.get(e.to)||0)+1));
    return toIds.every(id => (inc.get(id)||0) <= 1);
  }
  function isSurjective(fromIds, toIds, list){
    const inc = new Map(toIds.map(id=>[id,0]));
    list.forEach(e => inc.set(e.to,(inc.get(e.to)||0)+1));
    return toIds.every(id => (inc.get(id)||0) >= 1);
  }

  function compEdges(){ // g∘f
    const mapF = new Map(state.F.map(e=>[e.from,e.to]));
    const mapG = new Map(state.G.map(e=>[e.from,e.to]));
    const out = [];
    for (const [a,b] of mapF.entries()){
      const c = mapG.get(b);
      if (c) out.push({from:a,to:c});
    }
    return out;
  }

  function updateAll(){
    updateChecksAndScore();
    updateNarrative();
    state.needsDraw = true;
  }

  function updateChecksAndScore(){
    const T = L[state.lang];
    const A = idsOf("A"), B = idsOf("B"), C = idsOf("C");

    // 1) R: require ≥4 pairs
    const g1 = state.R.length >= 4;
    $("c1Val").textContent = (state.lang==='hu') ? `R párok: ${state.R.length}` : `R pairs: ${state.R.length}`;

    // 2) Reflexive on B
    const g2 = isReflexive(B, state.RB);
    $("c2Val").textContent = g2 ? "✓" : "✗";

    // 3) Equivalence on A
    const eq_ref = isReflexive(A, state.RA);
    const eq_sym = isSymmetric(A, state.RA);
    const eq_trn = isTransitive(A, state.RA);
    const g3 = eq_ref && eq_sym && eq_trn;
    $("c3Val").textContent = g3 ? "✓" : `R:${eq_ref?"✓":"✗"} S:${eq_sym?"✓":"✗"} T:${eq_trn?"✓":"✗"}`;

    // 4) Partial order on B
    const po_ref = g2;
    const po_as  = isAntisymmetric(B, state.RB);
    const po_trn = isTransitive(B, state.RB);
    const g4 = po_ref && po_as && po_trn;
    $("c4Val").textContent = g4 ? "✓" : `R:${po_ref?"✓":"✗"} AS:${po_as?"✓":"✗"} T:${po_trn?"✓":"✗"}`;

    // 5) f total
    const g5 = isFunction(A, B, state.F);
    $("c5Val").textContent = g5 ? "✓" : "✗";

    // 6) types: inj or surj (or both)
    const inj = g5 && isInjective(A, B, state.F);
    const sur = g5 && isSurjective(A, B, state.F);
    const bij = inj && sur;
    const g6 = inj || sur;
    $("c6Val").textContent = `inj ${inj?"✓":"✗"}, surj ${sur?"✓":"✗"}, bij ${bij?"✓":"✗"}`;

    // 7) composition well-defined: need f and g total
    const gfunc = isFunction(B, C, state.G);
    const g7 = g5 && gfunc; // both total
    $("c7Val").textContent = g7 ? "✓" : "✗";

    // 8) inverse exists for f iff bijective
    const g8 = bij;
    $("c8Val").textContent = g8 ? "✓" : "✗";

    // Score
    const goals = [g1,g2,g3,g4,g5,g6,g7,g8];
    const s = goals.reduce((a,b)=>a+(b?1:0),0);
    const pct = Math.round((s/8)*100);
    $("scoreText").textContent = (state.lang==='hu') ? `Pontszám: ${s}/8 (${pct}%)` : `Score: ${s}/8 (${pct}%)`;
    $("scoreFill").style.width = pct + "%";
  }

  function updateNarrative(){
    const T = L[state.lang];
    const A = idsOf("A"), B = idsOf("B"), C = idsOf("C");

    const g1 = state.R.length >= 4;
    const g2 = isReflexive(B, state.RB);
    const eq_ref = isReflexive(A, state.RA);
    const eq_sym = isSymmetric(A, state.RA);
    const eq_trn = isTransitive(A, state.RA);
    const g3 = eq_ref && eq_sym && eq_trn;
    const po_as = isAntisymmetric(B, state.RB);
    const po_trn = isTransitive(B, state.RB);
    const g4 = g2 && po_as && po_trn;
    const g5 = isFunction(A, B, state.F);
    const inj = g5 && isInjective(A, B, state.F);
    const sur = g5 && isSurjective(A, B, state.F);
    const bij = inj && sur;
    const g6 = inj || sur;
    const g7 = g5 && isFunction(B, C, state.G);
    const g8 = bij;

    const msgs = [];
    msgs.push(g1 ? `✓ ${T.g1_ok}` : `• ${T.g1_need}`);
    msgs.push(g2 ? `✓ ${T.g2_ok}` : `• ${T.g2_need}`);
    msgs.push(g3 ? `✓ ${T.g3_ok}` : `• ${T.g3_need}`);
    msgs.push(g4 ? `✓ ${T.g4_ok}` : `• ${T.g4_need}`);
    msgs.push(g5 ? `✓ ${T.g5_ok}` : `• ${T.g5_need}`);
    if (g6){
      if (bij) msgs.push(`✓ ${T.g6_ok_bij}`);
      else if (inj) msgs.push(`✓ ${T.g6_ok_inj}`);
      else if (sur) msgs.push(`✓ ${T.g6_ok_surj}`);
    } else {
      msgs.push(`• ${T.g6_need}`);
    }
    msgs.push(g7 ? `✓ ${T.g7_ok}` : `• ${T.g7_need}`);
    msgs.push(g8 ? `✓ ${T.g8_ok}` : `• ${T.g8_need}`);

    $("narrative").innerHTML = msgs.map(m => `<div>${m}</div>`).join("");
  }

  // ---------- Drawing ----------
  function rr(x,y,w,h,r){
    const R = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+R,y);
    ctx.arcTo(x+w,y, x+w,y+h, R);
    ctx.arcTo(x+w,y+h, x,y+h, R);
    ctx.arcTo(x,y+h, x,y, R);
    ctx.arcTo(x,y, x+w,y, R);
    ctx.closePath();
  }
  function drawDiamond(cx,cy,w,h){
    ctx.beginPath();
    ctx.moveTo(cx, cy-h/2);
    ctx.lineTo(cx+w/2, cy);
    ctx.lineTo(cx, cy+h/2);
    ctx.lineTo(cx-w/2, cy);
    ctx.closePath();
  }
  function drawLabel(cx, topY, text){
    ctx.font = "500 12px system-ui,-apple-system, Segoe UI, Roboto, Arial";
    const pad=6, tw = ctx.measureText(text).width + pad*2, th = 18;
    ctx.fillStyle = "rgba(12,18,32,0.92)";
    rr(cx - tw/2, topY - th/2, tw, th, 8); ctx.fill();
    ctx.strokeStyle = "#233040"; ctx.lineWidth = 1; rr(cx - tw/2, topY - th/2, tw, th, 8); ctx.stroke();
    ctx.fillStyle = "#d7e6ff"; ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(text, cx, topY);
  }
  function nodeXY(id){
    const n = nodeById(id);
    return [n.x*canvas.clientWidth, n.y*canvas.clientHeight];
  }
  function drawEdge(ax,ay,bx,by,color){
    ctx.strokeStyle = color; ctx.fillStyle=color; ctx.lineWidth=2.2;
    const mx = (ax+bx)/2, my = (ay+by)/2 - 16;
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.quadraticCurveTo(mx,my,bx,by); ctx.stroke();
    const ang = Math.atan2(by-my, bx-mx), s=6;
    ctx.beginPath();
    ctx.moveTo(bx,by);
    ctx.lineTo(bx - s*Math.cos(ang - Math.PI/6), by - s*Math.sin(ang - Math.PI/6));
    ctx.lineTo(bx - s*Math.cos(ang + Math.PI/6), by - s*Math.sin(ang + Math.PI/6));
    ctx.closePath(); ctx.fill();
  }

  async function draw(){
    state.needsDraw = false;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // Frame
    ctx.fillStyle = COL.frame; ctx.strokeStyle = COL.border; ctx.lineWidth = 1.5;
    rr(8.5,8.5,w-17,h-17,12); ctx.fill(); ctx.stroke();

    // Edges: B↔B and A↔A first (background)
    if (state.layers.RB){
      for (const e of state.RB){
        const [ax,ay] = nodeXY(e.from), [bx,by] = nodeXY(e.to);
        drawEdge(ax,ay,bx,by,COL.RB);
      }
    }
    if (state.layers.RA){
      for (const e of state.RA){
        const [ax,ay] = nodeXY(e.from), [bx,by] = nodeXY(e.to);
        drawEdge(ax,ay,bx,by,COL.RA);
      }
    }

    // R, g, f, comp
    if (state.layers.R){
      for (const e of state.R){
        const [ax,ay] = nodeXY(e.from), [bx,by] = nodeXY(e.to);
        drawEdge(ax,ay,bx,by,COL.R);
      }
    }
    if (state.layers.g){
      for (const e of state.G){
        const [ax,ay] = nodeXY(e.from), [bx,by] = nodeXY(e.to);
        drawEdge(ax,ay,bx,by,COL.g);
      }
    }
    if (state.layers.f){
      for (const e of state.F){
        const [ax,ay] = nodeXY(e.from), [bx,by] = nodeXY(e.to);
        drawEdge(ax,ay,bx,by,COL.f);
      }
    }
    if (state.layers.comp){
      for (const e of compEdges()){
        const [ax,ay] = nodeXY(e.from), [bx,by] = nodeXY(e.to);
        drawEdge(ax,ay,bx,by,COL.comp);
      }
    }

    // Nodes
    const showLabels = $("showLabels").checked;
    for (const n of state.nodes){
      const cx = n.x*w, cy = n.y*h;
      if (n.type==="A"){
        ctx.beginPath(); ctx.arc(cx,cy,n.w/2,0,Math.PI*2); ctx.closePath();
        ctx.fillStyle = "#0e1523"; ctx.strokeStyle = COL.A; ctx.lineWidth=2;
        ctx.fill(); ctx.stroke();
        if (showLabels) drawLabel(cx, cy + n.w/2 + 12, n.name);
      } else if (n.type==="B"){
        ctx.fillStyle = "#0e1523"; ctx.strokeStyle = COL.B; ctx.lineWidth=2;
        rr(cx-n.w/2, cy-n.h/2, n.w, n.h, 8); ctx.fill(); ctx.stroke();
        if (showLabels) drawLabel(cx, cy + n.h/2 + 12, n.name);
      } else {
        ctx.fillStyle = "#0e1523"; ctx.strokeStyle = COL.C; ctx.lineWidth=2;
        drawDiamond(cx,cy,n.w, n.h); ctx.fill(); ctx.stroke();
        if (showLabels) drawLabel(cx, cy + n.h/2 + 12, n.name);
      }
    }
  }

  // ---------- Wire up ----------
  $("btnReset").onclick = async ()=>{
    await loadAssets();
    buildTopUI();
    updateAll();
  };
  $("showLabels").onchange = ()=> state.needsDraw = true;

  // ---------- Loop ----------
  function loop(){ if (state.needsDraw) draw(); requestAnimationFrame(loop); }

  // ---------- Start ----------
  (async function boot(){
    resizeCanvas();
    await loadAssets();
    buildTopUI();
    updateAll();
    loop();
  })();

  // Resize handler
  window.addEventListener("resize", resizeCanvas);
})();
</script>
{% endblock %}
