{% extends "index.html" %}

{% block controls %}
<div class="controls" aria-label="Simulation controls">
  <button id="btnNewPuzzle" class="btn">New Puzzle</button>
  <label class="switch btn"><input id="lockSets" type="checkbox" /> Lock Sets</label>
  <label class="switch btn"><input id="lockElements" type="checkbox" /> Lock Elements</label>
  <label class="switch btn"><input id="showLabels" type="checkbox" checked /> Show Labels</label>
</div>
{% endblock %}

{% block content %}
<!-- Left: Canvas -->
<section class="canvas-card" aria-label="Universe canvas">
  <div id="hlChip" class="hl-chip" style="display:none;"></div>
  <canvas id="venn" role="img" aria-label="Interactive Venn canvas"></canvas>
</section>

<!-- Right: Sidebar -->
<aside>
  <div>
    <h2>Sets</h2>

    <!-- Universe + Score + Tips live here -->
    <div class="sets-top">
      <div class="badge">Universe: <strong id="uName">…</strong></div>

      <div class="score" aria-live="polite">
        <span id="scoreText">Score: 0/0 (0%)</span>
        <div class="bar"><div id="scoreFill" class="fill"></div></div>
      </div>

      <div class="tips">
        <div class="pill" style="margin-bottom:6px;">Tip</div>
        <div>Drag sets &amp; minerals • Wheel on a set to resize</div>
        <div>Click any row to highlight • Press <span class="kbd">Esc</span> to clear</div>
      </div>
    </div>

    <!-- Chips for each set -->
    <div id="setsChips" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;"></div>
  </div>

  <div class="summary" id="regions">
    <h2>Regions &amp; Intersections</h2>
    <!-- Filled dynamically -->
  </div>

  <div>
    <h2>Elements &amp; Membership</h2>
    <div style="overflow:auto; max-height: 38vh; border-radius:12px;">
      <table aria-label="elements membership table">
        <thead>
          <tr id="theadRow">
            <th>Mineral</th>
            <th>Status</th>
            <!-- set names appended dynamically -->
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>
</aside>

<!-- Bottom row under canvas -->
<section class="explain-card" aria-live="polite" aria-label="Text explanation for selected region">
  <div class="explain-head">
    <span class="badge">Selected region</span>
    <code id="expExpr">—</code>
    <span class="pill" id="expCount">(0 elements)</span>
  </div>
  <div class="explain-body" id="expText">
    Click a region to spotlight it. In this geology context, sets represent mineral-forming environments or processes; a mineral belongs to a set if its label lies inside that circle.
  </div>
  <div class="explain-body" id="expElements" style="display:none;">
    <strong>Elements in region:</strong>
    <ul class="exp-list" id="expList"></ul>
  </div>
</section>
{% endblock %}

{% block scripts %}
<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist = (x1,y1,x2,y2) => Math.hypot(x1-x2, y1-y2);
  const hexToRgb = (hex) => {
    const h = hex.replace("#","").trim();
    const n = parseInt(h.length === 3 ? h.split("").map(c=>c+c).join("") : h, 16);
    return {r:(n>>16)&255, g:(n>>8)&255, b:n&255};
  };
  const rgbToHex = ({r,g,b}) => "#" + [r,g,b].map(v => v.toString(16).padStart(2,"0")).join("");
  const mixColors = (hexes) => {
    if (!hexes.length) return "#95a3b8";
    let r=0,g=0,b=0; hexes.forEach(h=>{ const c=hexToRgb(h); r+=c.r; g+=c.g; b+=c.b; });
    const n = hexes.length;
    return rgbToHex({r:Math.round(r/n), g:Math.round(g/n), b:Math.round(b/n)});
  };
  const hexToRgba = (hex, a) => { const {r,g,b} = hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; };
  const sameSet = (A,B) => {
    if (!A || !B) return (!A || A.length===0) && (!B || B.length===0);
    if (A.length !== B.length) return false;
    const a = [...A].sort().join("|");
    const b = [...B].sort().join("|");
    return a === b;
  };

  // ---------- State ----------
  const canvas = document.getElementById("venn");
  const ctx = canvas.getContext("2d");
  const hlChip = document.getElementById("hlChip");

  const scoreText = document.getElementById("scoreText");
  const scoreFill = document.getElementById("scoreFill");

  const expExpr = document.getElementById("expExpr");
  const expCount = document.getElementById("expCount");
  const expText = document.getElementById("expText");
  const expElemsBlock = document.getElementById("expElements");
  const expList = document.getElementById("expList");

  const state = {
    universe: {name:"", width:1200, height:750},
    sets: [],
    elements: [],
    answerKey: {},
    solution: null,
    drag: null,
    highlight: null, // {kind:'single'|'pair'|'diff'|'sym'|'triple'|'outside'|'all'|'union', indices:[...]}
    needsDraw: true
  };

  // ---------- Responsive canvas ----------
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    requestDraw();
  }
  const S = () => Math.min(canvas.clientWidth, canvas.clientHeight);
  const pxX = nx => nx * canvas.clientWidth;
  const pxY = ny => ny * canvas.clientHeight;
  const nX  = px => clamp(px / canvas.clientWidth, 0, 1);
  const nY  = py => clamp(py / canvas.clientHeight, 0, 1);

  // ---------- Picking ----------
  function pickAt(px,py){
    for (let i=state.elements.length-1; i>=0; --i){
      const e = state.elements[i];
      if (dist(px,py,pxX(e.x),pxY(e.y)) <= 10) return {type:"element", index:i};
    }
    for (let i=state.sets.length-1; i>=0; --i){
      const s = state.sets[i];
      if (dist(px,py,pxX(s.x),pxY(s.y)) <= s.r * S()) return {type:"set", index:i};
    }
    return null;
  }

  // ---------- Membership & tallies ----------
  function memberships(){
    const n = state.sets.length;
    const counts = new Uint32Array(1<<n);
    const per = new Array(state.elements.length).fill(0);
    const centers = state.sets.map(s => ({cx:pxX(s.x), cy:pxY(s.y), r:s.r*S()}));

    for (let ei=0; ei<state.elements.length; ei++){
      const e = state.elements[ei];
      const ex = pxX(e.x), ey = pxY(e.y);
      let mask = 0;
      for (let si=0; si<n; si++){
        const {cx,cy,r} = centers[si];
        if (dist(ex,ey,cx,cy) <= r) mask |= (1<<si);
      }
      per[ei] = mask;
      counts[mask] += 1;
    }

    const total = state.elements.length;

    const singles = new Array(n).fill(0);
    for (let i=0;i<n;i++){
      let sum=0;
      for (let m=0;m<counts.length;m++) if (m & (1<<i)) sum += counts[m];
      singles[i]=sum;
    }

    const pairs = [];
    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++){
      let sum=0, need=(1<<i)|(1<<j);
      for (let m=0;m<counts.length;m++) if ((m & need) === need) sum += counts[m];
      pairs.push({i,j,count:sum});
    }

    const diffs = [];
    for (let i=0;i<n;i++){
      for (let j=0;j<n;j++){
        if (i===j) continue;
        let sum=0;
        for (let m=0;m<counts.length;m++){
          if ((m & (1<<i)) && !(m & (1<<j))) sum += counts[m];
        }
        diffs.push({i,j,count:sum});
      }
    }

    const syms = []; // NEW: symmetric differences (A Δ B)
    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++){
      let sum=0;
      for (let m=0;m<counts.length;m++){
        const a = (m & (1<<i)) !== 0;
        const b = (m & (1<<j)) !== 0;
        if (a ^ b) sum += counts[m];
      }
      syms.push({i,j,count:sum});
    }

    const unions2 = [];
    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++){
      let sum=0, need=(1<<i)|(1<<j);
      for (let m=0;m<counts.length;m++) if ((m & need) !== 0) sum += counts[m];
      unions2.push({i,j,count:sum});
    }

    const triples = [];
    if (n>=3){
      for (let i=0;i<n;i++) for (let j=i+1;j<n;j++) for (let k=j+1;k<n;k++){
        let sum=0, need=(1<<i)|(1<<j)|(1<<k);
        for (let m=0;m<counts.length;m++) if ((m & need) === need) sum += counts[m];
        triples.push({i,j,k,count:sum});
      }
    }

    return { perElement: per, countsByMask: counts, singles, pairs, diffs, syms, unions2, triples, total };
  }

  // ---------- Region logic ----------
  function prettyExpr(kind, idx){
    const id = (i) => state.sets[i]?.id || "?";
    if (kind==='single') return `${id(idx[0])}`;
    if (kind==='pair')   return `${id(idx[0])} ∩ ${id(idx[1])}`;
    if (kind==='diff')   return `${id(idx[0])} \\ ${id(idx[1])}`;
    if (kind==='sym')    return `${id(idx[0])} Δ ${id(idx[1])}`; // NEW
    if (kind==='union'){
      const parts = idx.map(i => id(i)).join(" ∪ ");
      return parts || "Union";
    }
    if (kind==='triple') return `${id(idx[0])} ∩ ${id(idx[1])} ∩ ${id(idx[2])}`;
    if (kind==='outside') return `Outside all sets`;
    if (kind==='all') return `Union (all sets)`;
    return '—';
  }

  function countForHighlight(kind, idx, counts, total){
    if (!kind) return 0;
    if (kind==='outside') return counts[0];
    if (kind==='all') return total - counts[0];
    let sum=0;
    for (let m=0;m<counts.length;m++){
      if (kind==='single'){ if (m & (1<<idx[0])) sum += counts[m]; }
      else if (kind==='pair'){ const need=(1<<idx[0])|(1<<idx[1]); if ((m & need) === need) sum += counts[m]; }
      else if (kind==='diff'){ if ((m & (1<<idx[0])) && !(m & (1<<idx[1]))) sum += counts[m]; }
      else if (kind==='sym'){  // NEW: XOR
        const a = (m & (1<<idx[0])) !== 0;
        const b = (m & (1<<idx[1])) !== 0;
        if (a ^ b) sum += counts[m];
      }
      else if (kind==='union'){ const need = idx.reduce((b,i)=> b | (1<<i), 0); if ((m & need) !== 0) sum += counts[m]; }
      else if (kind==='triple'){ const need=(1<<idx[0])|(1<<idx[1])|(1<<idx[2]); if ((m & need) === need) sum += counts[m]; }
    }
    return sum;
  }

  function elementInRegion(maskBits, kind, idx){
    if (kind==='outside') return maskBits === 0;
    if (kind==='all') return maskBits !== 0;
    if (kind==='single') return (maskBits & (1<<idx[0])) !== 0;
    if (kind==='pair')   return (maskBits & (1<<idx[0])) && (maskBits & (1<<idx[1]));
    if (kind==='diff')   return (maskBits & (1<<idx[0])) && !(maskBits & (1<<idx[1]));
    if (kind==='sym'){   // NEW: XOR
      const a = (maskBits & (1<<idx[0])) !== 0;
      const b = (maskBits & (1<<idx[1])) !== 0;
      return a ^ b;
    }
    if (kind==='union'){ const need = idx.reduce((b,i)=> b | (1<<i), 0); return (maskBits & need) !== 0; }
    if (kind==='triple') return (maskBits & (1<<idx[0])) && (maskBits & (1<<idx[1])) && (maskBits & (1<<idx[2]));
    return false;
  }

  // ---------- Mask for strong highlight ----------
  function makeMask(kind, indices){
    if (!kind) return null;
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // Helper to create a blank offscreen canvas with same pixel dims as main canvas
    const makeOff = () => {
      const c = document.createElement('canvas');
      c.width = canvas.width; c.height = canvas.height;
      const g = c.getContext('2d');
      g.setTransform(dpr,0,0,dpr,0,0);
      return {c, g};
    };

    const mask = document.createElement('canvas');
    mask.width = canvas.width; mask.height = canvas.height;
    const m = mask.getContext('2d');
    m.setTransform(dpr,0,0,dpr,0,0);
    m.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
    m.fillStyle = "#000";

    const fillCircle = (gc, i) => {
      const s = state.sets[i];
      gc.beginPath(); gc.arc(pxX(s.x), pxY(s.y), s.r*S(), 0, Math.PI*2); gc.closePath(); gc.fill();
    };

    if (kind === 'single'){
      fillCircle(m, indices[0]);

    } else if (kind === 'pair'){
      fillCircle(m, indices[0]);
      m.globalCompositeOperation = 'destination-in';
      fillCircle(m, indices[1]);

    } else if (kind === 'diff'){
      fillCircle(m, indices[0]);
      m.globalCompositeOperation = 'destination-out';
      fillCircle(m, indices[1]);

    } else if (kind === 'sym'){ // NEW: (A \ B) ∪ (B \ A)
      // Build A\B
      const {c: c1, g: g1} = makeOff();
      g1.fillStyle = "#000";
      fillCircle(g1, indices[0]);
      g1.globalCompositeOperation = 'destination-out';
      fillCircle(g1, indices[1]);

      // Build B\A
      const {c: c2, g: g2} = makeOff();
      g2.fillStyle = "#000";
      fillCircle(g2, indices[1]);
      g2.globalCompositeOperation = 'destination-out';
      fillCircle(g2, indices[0]);

      // Combine onto mask
      m.globalCompositeOperation = 'source-over';
      m.drawImage(c1, 0, 0);
      m.drawImage(c2, 0, 0);

    } else if (kind === 'triple'){
      fillCircle(m, indices[0]);
      m.globalCompositeOperation = 'destination-in';
      fillCircle(m, indices[1]);
      fillCircle(m, indices[2]);

    } else if (kind === 'outside'){
      m.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
      m.globalCompositeOperation = 'destination-out';
      for (let i=0;i<state.sets.length;i++){ fillCircle(m, i); }

    } else if (kind === 'union'){
      m.globalCompositeOperation = 'source-over';
      indices.forEach(i => fillCircle(m, i));

    } else if (kind === 'all'){
      for (let i=0;i<state.sets.length;i++){ fillCircle(m, i); }
    }
    return mask;
  }

  // ---------- Score ----------
  function uiUpdateScore(correct, total){
    const pct = total ? Math.round(100 * correct / total) : 0;
    scoreText.textContent = `Score: ${correct}/${total} (${pct}%)`;
    scoreFill.style.width = `${pct}%`;
  }

  function computeScore(mem){
    const idByIndex = state.sets.map(s => s.id);
    let correct = 0;
    for (let ei=0; ei<state.elements.length; ei++){
      const e = state.elements[ei];
      const mask = mem.perElement[ei];
      const got = [];
      for (let si=0; si<state.sets.length; si++){
        if (mask & (1<<si)) got.push(idByIndex[si]);
      }
      const want = state.answerKey[e.id] || [];
      if (sameSet(got, want)) correct += 1;
    }
    uiUpdateScore(correct, state.elements.length);
    return correct;
  }

  // ---------- Drawing ----------
  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }

  function drawStrongHighlight(hl, mem){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const mask = makeMask(hl.kind, hl.indices);

    // Dim
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,w,h);
    if (mask){
      ctx.globalCompositeOperation = 'destination-out';
      ctx.drawImage(mask, 0, 0, canvas.width, canvas.height, 0, 0, w, h);
    }
    ctx.restore();

    // Glow
    if (mask){
      ctx.save();
      ctx.drawImage(mask, 0, 0, canvas.width, canvas.height, 0, 0, w, h);
      ctx.globalCompositeOperation = 'source-in';
      ctx.fillStyle = 'rgba(255,213,74,0.38)';
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.shadowColor = 'rgba(255,213,74,0.85)';
      ctx.shadowBlur = 22;
      ctx.globalAlpha = 0.6;
      ctx.drawImage(mask, 0, 0, canvas.width, canvas.height, 0, 0, w, h);
      ctx.restore();
    }

    // Halo elements inside
    for (let ei=0; ei<state.elements.length; ei++){
      if (!elementInRegion(mem.perElement[ei], hl.kind, hl.indices)) continue;
      const e = state.elements[ei];
      const ex = pxX(e.x), ey = pxY(e.y);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,213,74,0.85)';
      ctx.beginPath(); ctx.arc(ex, ey, 12, 0, Math.PI*2); ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // Label chip
    const expr = prettyExpr(hl.kind, hl.indices);
    const count = countForHighlight(hl.kind, hl.indices, mem.countsByMask, mem.total);
    hlChip.style.display = 'block';
    hlChip.textContent = `${expr} — ${count} element${count===1?'':'s'}`;
  }

  function clearHighlightChip(){ hlChip.style.display = 'none'; }

  function draw(){
    state.needsDraw = false;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // Universe frame card
    ctx.save();
    ctx.fillStyle = "#0c1220";
    ctx.strokeStyle = "#223045";
    ctx.lineWidth = 1.5;
    roundRect(ctx, 8.5, 8.5, w-17, h-17, 12);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    // Sets
    for (const s of state.sets){
      const cx = pxX(s.x), cy = pxY(s.y), r = s.r * S();
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.closePath();
      ctx.fillStyle = hexToRgba(s.color, 0.17); ctx.fill();
      ctx.lineWidth = 2.0; ctx.strokeStyle = s.color; ctx.stroke();

      // Name badge centered on the set
      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      const text = s.name;
      const tw = ctx.measureText(text).width + 12, th = 22;
      ctx.fillStyle = "rgba(13,19,32,0.85)";
      roundRect(ctx, cx - tw/2, cy - th/2, tw, th, 9); ctx.fill();
      ctx.fillStyle = "#cfe0ff"; ctx.fillText(text, cx, cy+0.5);
    }

    // Elements
    const mem = memberships();
    for (let ei=0; ei<state.elements.length; ei++){
      const e = state.elements[ei];
      const ex = pxX(e.x), ey = pxY(e.y);
      const mask = mem.perElement[ei];
      const colors = [];
      for (let si=0; si<state.sets.length; si++) if (mask & (1<<si)) colors.push(state.sets[si].color);
      const stroke = colors.length ? mixColors(colors) : "#9fb2c7";

      ctx.beginPath(); ctx.arc(ex, ey, 6, 0, Math.PI*2); ctx.closePath();
      ctx.fillStyle = "#0d1320"; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = stroke; ctx.stroke();

      if (document.getElementById("showLabels").checked){
        const label = e.label;
        ctx.font = "500 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "left"; ctx.textBaseline = "middle";
        const padX = 9, tw = ctx.measureText(label).width + padX*2, th = 20;
        ctx.fillStyle = "rgba(10,16,28,0.9)";
        roundRect(ctx, ex + 10, ey - th/2, tw, th, 8); ctx.fill();
        ctx.strokeStyle = "#233040"; ctx.lineWidth = 1;
        roundRect(ctx, ex + 10, ey - th/2, tw, th, 8); ctx.stroke();
        ctx.fillStyle = "#d7e6ff"; ctx.fillText(label, ex + 10 + padX, ey+0.5);
      }
    }

    // Score every frame
    computeScore(mem);

    // Overlay highlight (if any)
    if (state.highlight){
      drawStrongHighlight(state.highlight, mem);
      updateExplain(state.highlight, mem);
    } else {
      clearHighlightChip();
    }
  }

  // ---------- Explanation ----------
  function updateExplain(hl, mem){
    const expr = prettyExpr(hl.kind, hl.indices);
    const count = countForHighlight(hl.kind, hl.indices, mem.countsByMask, mem.total);

    expExpr.textContent = expr;
    expCount.textContent = `(${count} element${count===1?'':'s'})`;

    const items = [];
    for (let i=0; i<state.elements.length; i++){
      if (elementInRegion(mem.perElement[i], hl.kind, hl.indices)){
        items.push(state.elements[i].label);
      }
    }
    expList.innerHTML = items.map(t => `<li>${t}</li>`).join("") || `<li><em>None</em></li>`;
    expElemsBlock.style.display = 'block';

    const name = (i) => state.sets[i]?.name || `Set ${i+1}`;
    const id   = (i) => state.sets[i]?.id   || `S${i+1}`;

    let desc = "";
    if (hl.kind === 'single'){
      desc = `Minerals inside **${name(hl.indices[0])}** (${id(hl.indices[0])}).`;
    } else if (hl.kind === 'pair'){
      desc = `Intersection **${id(hl.indices[0])} ∩ ${id(hl.indices[1])}** shared by **${name(hl.indices[0])}** and **${name(hl.indices[1])}**.`;
    } else if (hl.kind === 'diff'){
      desc = `Difference **${id(hl.indices[0])} \\ ${id(hl.indices[1])}** — in **${name(hl.indices[0])}** but not in **${name(hl.indices[1])}**.`;
    } else if (hl.kind === 'sym'){
      desc = `Symmetric difference **${id(hl.indices[0])} Δ ${id(hl.indices[1])}** — minerals in exactly one of the two sets (formula: **(A \\ B) ∪ (B \\ A)**).`;
    } else if (hl.kind === 'union'){
      const human = hl.indices.map(i => `${name(i)} (${id(i)})`).join(" or ");
      desc = `Union **${prettyExpr('union', hl.indices)}** — minerals in ${human}.`;
    } else if (hl.kind === 'triple'){
      desc = `Triple intersection — minerals belonging to all three sets.`;
    } else if (hl.kind === 'outside'){
      const unionIds = state.sets.map(s=>s.id).join(" ∪ ");
      desc = `Complement **U \\ (${unionIds})** — outside all sets.`;
    } else if (hl.kind === 'all'){
      const unionNames = state.sets.map(s=>`${s.name} (${s.id})`).join(", ");
      desc = `Union of all sets (${unionNames}).`;
    }
    desc += ` A mineral is a member if its label lies inside that set’s circle.`;
    expText.innerHTML = desc;
  }

  // ---------- UI builders ----------
  function rebuildSetChips(){
    const setsChipsEl = document.getElementById("setsChips");
    setsChipsEl.innerHTML = "";
    state.sets.forEach((s) => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.innerHTML = `<span class="dot" style="background:${s.color}"></span><strong>${s.name}</strong> <small>(${s.id})</small>`;
      chip.title = `Set ${s.name} [${s.id}]`;
      setsChipsEl.appendChild(chip);
    });

    const theadRowEl = document.getElementById("theadRow");
    while (theadRowEl.children.length > 2) theadRowEl.removeChild(theadRowEl.lastChild);
    state.sets.forEach(s => {
      const th = document.createElement("th");
      th.textContent = s.name;
      theadRowEl.appendChild(th);
    });
  }

  function updateRegionsAndTable(){
    const { countsByMask, singles, pairs, diffs, syms, unions2, triples, perElement, total } = memberships();
    const n = state.sets.length;
    const outside = countsByMask[0];

    const regionsEl = document.getElementById("regions");
    regionsEl.innerHTML = `<h2>Regions &amp; Intersections</h2>`;

    const addSubhead = (text) => {
      const row = document.createElement("div");
      row.className = "row subhead";
      row.textContent = text;
      regionsEl.appendChild(row);
    };

    const addRow = (lhsHtml, k, kind=null, indices=[]) => {
      const row = document.createElement("div");
      row.className = "row";
      row.innerHTML = `<div class="lhs">${lhsHtml}</div><div class="k">${k}</div>`;
      if (kind){
        row.dataset.kind = kind;
        row.dataset.indices = indices.join(",");
        row.title = "Click to highlight this region";
        row.addEventListener("click", () => {
          const same = state.highlight &&
                       state.highlight.kind === kind &&
                       JSON.stringify(state.highlight.indices) === JSON.stringify(indices);
          state.highlight = same ? null : {kind, indices};
          document.querySelectorAll(".summary .row").forEach(el => el.classList.remove("selected"));
          if (!same) row.classList.add("selected");
          if (same) { clearHighlightChip(); }
          requestDraw();
        });
      } else { row.style.cursor = "default"; }
      if (state.highlight && state.highlight.kind === kind &&
          JSON.stringify(state.highlight.indices) === JSON.stringify(indices)){
        row.classList.add("selected");
      }
      regionsEl.appendChild(row);
    };

    // Totals
    addSubhead("Totals");
    addRow(`<span class="badge">Total minerals</span>`, total, null, []);
    addRow(`<span class="badge">Outside all sets</span>`, outside, "outside", []);
    addRow(`<span class="badge">Union (all sets)</span>`, total - outside, "all", []);

    // Singles
    addSubhead("Singles (Inside A)");
    singles.forEach((cnt, i) => {
      const s = state.sets[i];
      addRow(`<span class="badge"><span class="dot" style="background:${s.color}"></span>${s.name}</span>`, cnt, "single", [i]);
    });

    // Intersections
    if (pairs.length){
      addSubhead("Intersections (A ∩ B)");
      pairs.forEach(({i,j,count}) => {
        const a = state.sets[i], b = state.sets[j];
        const dot = `<span class="dot" style="background:${mixColors([a.color,b.color])}"></span>`;
        addRow(`${dot}<code>${a.id} ∩ ${b.id}</code>`, count, "pair", [i,j]);
      });
    }

    // Differences
    if (diffs.length){
      addSubhead("Differences (A \\ B)");
      diffs.forEach(({i,j,count}) => {
        const a = state.sets[i], b = state.sets[j];
        addRow(`<span class="dot" style="background:${a.color}"></span><code>${a.id} \\ ${b.id}</code>`,
               count, "diff", [i,j]);
      });
    }

    // Symmetric differences (NEW)
    if (syms.length){
      addSubhead("Symmetric Differences (A Δ B)");
      syms.forEach(({i,j,count}) => {
        const a = state.sets[i], b = state.sets[j];
        const dot = `<span class="dot" style="background:${mixColors([a.color,b.color])}"></span>`;
        addRow(`${dot}<code>${a.id} Δ ${b.id}</code>`, count, "sym", [i,j]);
      });
    }

    // Unions
    if (unions2.length){
      addSubhead("Unions (A ∪ B)");
      unions2.forEach(({i,j,count}) => {
        const a = state.sets[i], b = state.sets[j];
        const dot = `<span class="dot" style="background:${mixColors([a.color,b.color])}"></span>`;
        addRow(`${dot}<code>${a.id} ∪ ${b.id}</code>`, count, "union", [i,j]);
      });
    }

    // Triple intersections
    if (triples.length){
      addSubhead("Triple Intersections (A ∩ B ∩ C)");
      triples.forEach(({i,j,k,count}) => {
        const a = state.sets[i], b = state.sets[j], c = state.sets[k];
        const dot = `<span class="dot" style="background:${mixColors([a.color,b.color,c.color])}"></span>`;
        addRow(`${dot}<code>${a.id} ∩ ${b.id} ∩ ${c.id}</code>`, count, "triple", [i,j,k]);
      });
    }

    // Elements table
    const tbodyEl = document.getElementById("tbody");
    tbodyEl.innerHTML = "";
    const idByIndex = state.sets.map(s => s.id);

    state.elements.forEach((e, idx) => {
      const tr = document.createElement("tr");

      const name = document.createElement("td");
      name.textContent = e.label;
      tr.appendChild(name);

      // status cell
      const mask = perElement[idx];
      const got = [];
      for (let si=0; si<n; si++) if (mask & (1<<si)) got.push(idByIndex[si]);
      const want = state.answerKey[e.id] || [];
      const ok = sameSet(got, want);
      const tdStatus = document.createElement("td");
      tdStatus.innerHTML = ok ? `<span class="ok">✓</span>` : `<span class="bad">✗</span>`;
      tr.appendChild(tdStatus);

      // membership cells
      for (let si=0; si<n; si++){
        const td = document.createElement("td");
        td.className = "k";
        td.textContent = (mask & (1<<si)) ? "✓" : "—";
        tr.appendChild(td);
      }
      tbodyEl.appendChild(tr);
    });
  }

  // ---------- Interaction ----------
  function onPointerDown(ev){
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
    const pick = pickAt(x,y);
    if (!pick) return;

    if (pick.type === "set" && document.getElementById("lockSets").checked) return;
    if (pick.type === "element" && document.getElementById("lockElements").checked) return;

    state.drag = {type: pick.type, index: pick.index, dx:0, dy:0};
    if (pick.type === "set"){
      const s = state.sets[pick.index];
      state.drag.dx = pxX(s.x) - x;
      state.drag.dy = pxY(s.y) - y;
    } else {
      const e = state.elements[pick.index];
      state.drag.dx = pxX(e.x) - x;
      state.drag.dy = pxY(e.y) - y;
    }
    ev.preventDefault();
  }

  function onPointerMove(ev){
    if (!state.drag) return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
    const nx = nX(x + state.drag.dx);
    const ny = nY(y + state.drag.dy);

    if (state.drag.type === "set"){
      const s = state.sets[state.drag.index];
      const rpx = s.r * S();
      const minX = rpx / canvas.clientWidth;
      const maxX = 1 - minX;
      const minY = rpx / canvas.clientHeight;
      const maxY = 1 - minY;
      s.x = clamp(nx, minX, maxX);
      s.y = clamp(ny, minY, maxY);
    } else {
      const e = state.elements[state.drag.index];
      e.x = clamp(nx, 0, 1);
      e.y = clamp(ny, 0, 1);
    }
    requestDraw();
    ev.preventDefault();
  }

  function onPointerUp(){ state.drag = null; }

  function onWheel(ev){
    if (document.getElementById("lockSets").checked) return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
    const pick = pickAt(x,y);
    if (!pick || pick.type !== "set") return;

    const s = state.sets[pick.index];
    const factor = (ev.deltaY < 0) ? 1.05 : 0.95;
    s.r = clamp(s.r * factor, 0.06, 0.5);

    // keep inside
    const rpx = s.r * S();
    const minX = rpx / canvas.clientWidth;
    const maxX = 1 - minX;
    const minY = rpx / canvas.clientHeight;
    const maxY = 1 - minY;
    s.x = clamp(s.x, minX, maxX);
    s.y = clamp(s.y, minY, maxY);

    requestDraw();
    ev.preventDefault();
  }

  // Keyboard: Esc to clear highlight
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && state.highlight){
      state.highlight = null;
      document.querySelectorAll(".summary .row").forEach(el => el.classList.remove("selected"));
      clearHighlightChip();
      expExpr.textContent = "—";
      expCount.textContent = "(0 elements)";
      expText.innerHTML = "Click a region to spotlight it. In this geology context, sets represent mineral-forming environments or processes; a mineral belongs to a set if its label lies inside that circle.";
      expElemsBlock.style.display = 'none';
      requestDraw();
    }
  });

  // ---------- Puzzle ----------
  async function newPuzzle(){
    const seed = Date.now();
    const res = await fetch(`/api/puzzle?seed=${seed}`);
    const data = await res.json();
    state.universe = data.universe;
    state.sets = data.sets;
    state.elements = data.elements;
    state.answerKey = data.answer_key || {};
    state.solution = data.solution || null;
    document.getElementById("uName").textContent = state.universe.name || "Universe (U)";
    document.querySelectorAll(".summary .row").forEach(el => el.classList.remove("selected"));
    state.highlight = null;
    rebuildSetChips();
    requestDraw();
    updateRegionsAndTable();
  }

  // ---------- Animation loop ----------
  function requestDraw(){ state.needsDraw = true; }
  function loop(){
    if (state.needsDraw){
      draw();
      updateRegionsAndTable();
    }
    requestAnimationFrame(loop);
  }

  // ---------- Wire up ----------
  window.addEventListener("resize", resizeCanvas);
  canvas.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove);
  window.addEventListener("pointerup", onPointerUp);
  canvas.addEventListener("wheel", onWheel, {passive:false});

  document.getElementById("btnNewPuzzle").addEventListener("click", newPuzzle);
  document.getElementById("showLabels").addEventListener("change", requestDraw);

  // ---------- Boot ----------
  (async function boot(){
    resizeCanvas();
    await newPuzzle();   // start in scrambled mode
    loop();
  })();
})();
</script>
{% endblock %}
