{% extends "index.html" %}

{% block controls %}
<div class="controls" aria-label="Simulation controls">
  <button id="btnNewPuzzle" class="btn">New Puzzle</button>
  <label class="switch btn"><input id="lockSets" type="checkbox" /> Lock Sets</label>
  <label class="switch btn"><input id="lockElements" type="checkbox" /> Lock Elements</label>
  <label class="switch btn"><input id="showLabels" type="checkbox" checked /> Show Labels</label>
</div>
{% endblock %}

{% block content %}
<section class="canvas-card" aria-label="Universe canvas">
  <!-- Top-left head: Universe & score -->
  <div class="canvas-head">
    <span class="badge">Universe: <strong id="uName">…</strong></span>
    <div class="score" aria-live="polite" style="margin-left:6px;">
      <span id="scoreText">Score: 0/0 (0%)</span>
      <div class="bar"><div id="scoreFill" class="fill"></div></div>
    </div>
    <span class="kbd" style="margin-left:6px;">Tip:</span><span class="pill">Drag sets &amp; minerals • Wheel on a set to resize</span>
  </div>

  <!-- Top-right hint -->
  <div class="canvas-hint">
    <span class="pill">Click any row to highlight • Press <span class="kbd">Esc</span> to clear</span>
  </div>

  <!-- TOP info bar (dynamic explanation) -->
  <div class="info-bar" id="infoBar" aria-live="polite">
    <div>
      <code id="expExpr">—</code>
      <span class="pill" id="expCount">(0 elements)</span>
    </div>
    <div class="info-text" id="expText">
      Click a region to spotlight it. In this geology context, sets represent mineral-forming environments or processes; a mineral belongs to a set if its label lies inside that circle.
    </div>
    <div class="info-list" id="expElements" style="display:none;">
      <!-- tags injected -->
    </div>
  </div>

  <div id="hlChip" class="hl-chip" style="display:none;"></div>
  <canvas id="venn" role="img" aria-label="Interactive Venn canvas"></canvas>
</section>

<aside>
  <div>
    <h2>Sets</h2>
    <div id="setsChips" style="display:flex; flex-wrap:wrap; gap:6px;"></div>
  </div>

  <div class="summary" id="regions">
    <h2>Regions &amp; Intersections</h2>
    <!-- filled dynamically -->
  </div>

  <div>
    <h2>Elements &amp; Membership</h2>
    <div style="overflow:auto; max-height: 38vh; border-radius:12px;">
      <table aria-label="elements membership table">
        <thead>
          <tr id="theadRow">
            <th>Mineral</th>
            <th>Status</th>
            <!-- set names appended dynamically -->
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
    <ul class="help-list">
      <li>Place sets so that minerals end up inside their correct categories. The score rises as memberships match the answer key.</li>
      <li>Use <strong>New Puzzle</strong> for a fresh scramble.</li>
    </ul>
  </div>
</aside>
{% endblock %}

{% block scripts %}
<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist = (x1,y1,x2,y2) => Math.hypot(x1-x2, y1-y2);
  const hexToRgb = (hex) => { const h = hex.replace("#","").trim(); const n = parseInt(h.length===3? h.split("").map(c=>c+c).join(""):h,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; };
  const rgbToHex = ({r,g,b}) => "#" + [r,g,b].map(v => v.toString(16).padStart(2,"0")).join("");
  const mixColors = (hexes) => { if (!hexes.length) return "#95a3b8"; let r=0,g=0,b=0; hexes.forEach(h=>{ const c=hexToRgb(h); r+=c.r; g+=c.g; b+=c.b; }); const n=hexes.length; return rgbToHex({r:Math.round(r/n),g:Math.round(g/n),b:Math.round(b/n)}); };
  const hexToRgba = (hex, a) => { const {r,g,b} = hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; };
  const sameSet = (A,B) => { if (!A||!B) return (!A||A.length===0)&&(!B||B.length===0); if (A.length!==B.length) return false; return [...A].sort().join("|") === [...B].sort().join("|"); };

  // ---------- State ----------
  const canvas = document.getElementById("venn");
  const ctx = canvas.getContext("2d");
  const hlChip = document.getElementById("hlChip");
  const scoreText = document.getElementById("scoreText");
  const scoreFill = document.getElementById("scoreFill");

  // Info bar refs (moved to top)
  const expExpr = document.getElementById("expExpr");
  const expCount = document.getElementById("expCount");
  const expText = document.getElementById("expText");
  const expListWrap = document.getElementById("expElements");

  const state = {
    universe: {name:"", width:1200, height:750},
    sets: [],
    elements: [],
    answerKey: {},
    solution: null,
    drag: null,
    highlight: null,
    needsDraw: true
  };

  // ---------- Geometry helpers ----------
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    requestDraw();
  }
  const S = () => Math.min(canvas.clientWidth, canvas.clientHeight);
  const pxX = nx => nx * canvas.clientWidth;
  const pxY = ny => ny * canvas.clientHeight;
  const nX  = px => Math.max(0, Math.min(1, px / canvas.clientWidth));
  const nY  = py => Math.max(0, Math.min(1, py / canvas.clientHeight));

  // ---------- Picking ----------
  function pickAt(px,py){
    for (let i=state.elements.length-1; i>=0; --i){
      const e = state.elements[i];
      if (dist(px,py,pxX(e.x),pxY(e.y)) <= 10) return {type:"element", index:i};
    }
    for (let i=state.sets.length-1; i>=0; --i){
      const s = state.sets[i];
      if (dist(px,py,pxX(s.x),pxY(s.y)) <= s.r * S()) return {type:"set", index:i};
    }
    return null;
  }

  // ---------- Membership ----------
  function memberships(){
    const n = state.sets.length;
    const counts = new Uint32Array(1<<n);
    const per = new Array(state.elements.length).fill(0);
    const centers = state.sets.map(s => ({cx:pxX(s.x), cy:pxY(s.y), r:s.r*S()}));

    for (let ei=0; ei<state.elements.length; ei++){
      const e = state.elements[ei];
      const ex = pxX(e.x), ey = pxY(e.y);
      let mask = 0;
      for (let si=0; si<n; si++){
        const {cx,cy,r} = centers[si];
        if (dist(ex,ey,cx,cy) <= r) mask |= (1<<si);
      }
      per[ei] = mask;
      counts[mask] += 1;
    }

    const total = state.elements.length;
    const singles = new Array(n).fill(0);
    for (let i=0;i<n;i++){
      let sum=0;
      for (let m=0;m<counts.length;m++) if (m & (1<<i)) sum += counts[m];
      singles[i]=sum;
    }

    const pairs = [];
    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++){
      let sum=0, need=(1<<i)|(1<<j);
      for (let m=0;m<counts.length;m++) if ((m & need) === need) sum += counts[m];
      pairs.push({i,j,count:sum});
    }

    const diffs = [];
    for (let i=0;i<n;i++){
      for (let j=0;j<n;j++){
        if (i===j) continue;
        let sum=0;
        for (let m=0;m<counts.length;m++){
          if ((m & (1<<i)) && !(m & (1<<j))) sum += counts[m];
        }
        diffs.push({i,j,count:sum});
      }
    }

    const unions2 = [];
    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++){
      let sum=0, need=(1<<i)|(1<<j);
      for (let m=0;m<counts.length;m++) if ((m & need) !== 0) sum += counts[m];
      unions2.push({i,j,count:sum});
    }

    const triples = [];
    if (n>=3){
      for (let i=0;i<n;i++) for (let j=i+1;j<n;j++) for (let k=j+1;k<n;k++){
        let sum=0, need=(1<<i)|(1<<j)|(1<<k);
        for (let m=0;m<counts.length;m++) if ((m & need) === need) sum += counts[m];
        triples.push({i,j,k,count:sum});
      }
    }

    return { perElement: per, countsByMask: counts, singles, pairs, diffs, unions2, triples, total };
  }

  // ---------- Regions ----------
  function prettyExpr(kind, idx){
    const id = (i) => state.sets[i]?.id || "?";
    if (kind==='single') return `${id(idx[0])}`;
    if (kind==='pair')   return `${id(idx[0])} ∩ ${id(idx[1])}`;
    if (kind==='diff')   return `${id(idx[0])} \\ ${id(idx[1])}`;
    if (kind==='union'){ const parts = idx.map(i => id(i)).join(" ∪ "); return parts || "Union"; }
    if (kind==='triple') return `${id(idx[0])} ∩ ${id(idx[1])} ∩ ${id(idx[2])}`;
    if (kind==='outside') return `Outside all sets`;
    if (kind==='all') return `Union (all sets)`;
    return '—';
  }

  function countForHighlight(kind, idx, counts, total){
    if (!kind) return 0;
    if (kind==='outside') return counts[0];
    if (kind==='all') return total - counts[0];
    let sum=0;
    for (let m=0;m<counts.length;m++){
      if (kind==='single'){ if (m & (1<<idx[0])) sum += counts[m]; }
      else if (kind==='pair'){ const need=(1<<idx[0])|(1<<idx[1]); if ((m & need) === need) sum += counts[m]; }
      else if (kind==='diff'){ if ((m & (1<<idx[0])) && !(m & (1<<idx[1]))) sum += counts[m]; }
      else if (kind==='union'){ const need = idx.reduce((b,i)=> b | (1<<i), 0); if ((m & need) !== 0) sum += counts[m]; }
      else if (kind==='triple'){ const need=(1<<idx[0])|(1<<idx[1])|(1<<idx[2]); if ((m & need) === need) sum += counts[m]; }
    }
    return sum;
  }

  function elementInRegion(maskBits, kind, idx){
    if (kind==='outside') return maskBits === 0;
    if (kind==='all') return maskBits !== 0;
    if (kind==='single') return (maskBits & (1<<idx[0])) !== 0;
    if (kind==='pair')   return (maskBits & (1<<idx[0])) && (maskBits & (1<<idx[1]));
    if (kind==='diff')   return (maskBits & (1<<idx[0])) && !(maskBits & (1<<idx[1]));
    if (kind==='union'){ const need = idx.reduce((b,i)=> b | (1<<i), 0); return (maskBits & need) !== 0; }
    if (kind==='triple') return (maskBits & (1<<idx[0])) && (maskBits & (1<<idx[1])) && (maskBits & (1<<idx[2]));
    return false;
  }

  // ---------- Masks ----------
  function makeMask(kind, indices){
    if (!kind) return null;
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const mask = document.createElement('canvas');
    mask.width = canvas.width; mask.height = canvas.height;
    const m = mask.getContext('2d');
    m.setTransform(dpr,0,0,dpr,0,0);
    m.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
    m.fillStyle = "#000";
    const fillCircle = (i) => { const s = state.sets[i]; m.beginPath(); m.arc(pxX(s.x), pxY(s.y), s.r*S(), 0, Math.PI*2); m.closePath(); m.fill(); };

    if (kind === 'single'){ fillCircle(indices[0]); }
    else if (kind === 'pair'){ fillCircle(indices[0]); m.globalCompositeOperation = 'destination-in'; fillCircle(indices[1]); }
    else if (kind === 'diff'){ fillCircle(indices[0]); m.globalCompositeOperation = 'destination-out'; fillCircle(indices[1]); }
    else if (kind === 'triple'){ fillCircle(indices[0]); m.globalCompositeOperation = 'destination-in'; fillCircle(indices[1]); fillCircle(indices[2]); }
    else if (kind === 'outside'){ m.fillRect(0,0,canvas.clientWidth, canvas.clientHeight); m.globalCompositeOperation = 'destination-out'; for (let i=0;i<state.sets.length;i++) fillCircle(i); }
    else if (kind === 'union'){ m.globalCompositeOperation = 'source-over'; indices.forEach(i => fillCircle(i)); }
    else if (kind === 'all'){ for (let i=0;i<state.sets.length;i++) fillCircle(i); }
    return mask;
  }

  // ---------- Score ----------
  function uiUpdateScore(correct, total){
    const pct = total ? Math.round(100 * correct / total) : 0;
    scoreText.textContent = `Score: ${correct}/${total} (${pct}%)`;
    scoreFill.style.width = `${pct}%`; // green loading bar
  }

  function computeScore(mem){
    const idByIndex = state.sets.map(s => s.id);
    let correct = 0;
    for (let ei=0; ei<state.elements.length; ei++){
      const e = state.elements[ei];
      const mask = mem.perElement[ei];
      const got = [];
      for (let si=0; si<state.sets.length; si++) if (mask & (1<<si)) got.push(idByIndex[si]);
      const want = state.answerKey[e.id] || [];
      if (sameSet(got, want)) correct += 1;
    }
    uiUpdateScore(correct, state.elements.length);
    return correct;
  }

  // ---------- Draw ----------
  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }

  function drawStrongHighlight(hl, mem){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const mask = makeMask(hl.kind, hl.indices);

    // Dim background
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,w,h);
    if (mask){
      ctx.globalCompositeOperation = 'destination-out';
      ctx.drawImage(mask, 0, 0, canvas.width, canvas.height, 0, 0, w, h);
    }
    ctx.restore();

    // Colorize + glow
    if (mask){
      ctx.save();
      ctx.drawImage(mask, 0, 0, canvas.width, canvas.height, 0, 0, w, h);
      ctx.globalCompositeOperation = 'source-in';
      ctx.fillStyle = 'rgba(255,213,74,0.38)';
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.shadowColor = 'rgba(255,213,74,0.85)';
      ctx.shadowBlur = 22;
      ctx.globalAlpha = 0.6;
      ctx.drawImage(mask, 0, 0, canvas.width, canvas.height, 0, 0, w, h);
      ctx.restore();
    }

    // Outline involved sets
    const ids = hl.indices || [];
    if (hl.kind !== 'outside'){
      const color = ids.length ? mixColors(ids.map(i => state.sets[i].color)) : "#ffd54a";
      ids.forEach(i => {
        const s = state.sets[i];
        ctx.save();
        ctx.lineWidth = 4.5;
        ctx.strokeStyle = hexToRgba(color, 0.95);
        ctx.shadowColor = hexToRgba(color, 0.95);
        ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(pxX(s.x), pxY(s.y), s.r*S(), 0, Math.PI*2); ctx.closePath();
        ctx.stroke();
        ctx.restore();
      });
    }

    // Halo elements
    for (let ei=0; ei<state.elements.length; ei++){
      if (!elementInRegion(mem.perElement[ei], hl.kind, hl.indices)) continue;
      const e = state.elements[ei];
      const ex = pxX(e.x), ey = pxY(e.y);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,213,74,0.85)';
      ctx.beginPath(); ctx.arc(ex, ey, 12, 0, Math.PI*2); ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // On-canvas chip
    const expr = prettyExpr(hl.kind, hl.indices);
    const count = countForHighlight(hl.kind, hl.indices, mem.countsByMask, mem.total);
    hlChip.style.display = 'block';
    hlChip.textContent = `${expr} — ${count} element${count===1?'':'s'}`;
  }

  function clearHighlightChip(){ hlChip.style.display = 'none'; }

  function draw(){
    state.needsDraw = false;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // Universe frame
    ctx.save();
    ctx.fillStyle = "#0c1220";
    ctx.strokeStyle = "#223045";
    ctx.lineWidth = 1.5;
    roundRect(ctx, 8.5, 8.5, w-17, h-17, 12);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    // Sets
    for (const s of state.sets){
      const cx = pxX(s.x), cy = pxY(s.y), r = s.r * S();
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.closePath();
      ctx.fillStyle = hexToRgba(s.color, 0.17); ctx.fill();
      ctx.lineWidth = 2.0; ctx.strokeStyle = s.color; ctx.stroke();

      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      const text = s.name;
      const tw = ctx.measureText(text).width + 12, th = 22;
      ctx.fillStyle = "rgba(13,19,32,0.85)";
      roundRect(ctx, cx - tw/2, cy - th/2, tw, th, 9); ctx.fill();
      ctx.fillStyle = "#cfe0ff"; ctx.fillText(text, cx, cy+0.5);
    }

    // Elements
    const mem = memberships();
    for (let ei=0; ei<state.elements.length; ei++){
      const e = state.elements[ei];
      const ex = pxX(e.x), ey = pxY(e.y);
      const mask = mem.perElement[ei];
      const colors = [];
      for (let si=0; si<state.sets.length; si++) if (mask & (1<<si)) colors.push(state.sets[si].color);
      const stroke = colors.length ? mixColors(colors) : "#9fb2c7";

      ctx.beginPath(); ctx.arc(ex, ey, 6, 0, Math.PI*2); ctx.closePath();
      ctx.fillStyle = "#0d1320"; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = stroke; ctx.stroke();

      if (document.getElementById("showLabels").checked){
        const label = e.label;
        ctx.font = "500 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "left"; ctx.textBaseline = "middle";
        const padX = 9, tw = ctx.measureText(label).width + padX*2, th = 20;
        ctx.fillStyle = "rgba(10,16,28,0.9)";
        roundRect(ctx, ex + 10, ey - th/2, tw, th, 8); ctx.fill();
        ctx.strokeStyle = "#233040"; ctx.lineWidth = 1;
        roundRect(ctx, ex + 10, ey - th/2, tw, th, 8); ctx.stroke();
        ctx.fillStyle = "#d7e6ff"; ctx.fillText(label, ex + 10 + padX, ey+0.5);
      }
    }

    // Score update
    computeScore(mem);

    // Overlay highlight
    if (state.highlight){
      drawStrongHighlight(state.highlight, mem);
      updateInfo(state.highlight, mem);
    } else {
      clearHighlightChip();
      // show default text if nothing selected
      defaultInfo();
    }
  }

  function requestDraw(){ state.needsDraw = true; }

  // ---------- Info bar (top) ----------
  function defaultInfo(){
    expExpr.textContent = "—";
    expCount.textContent = "(0 elements)";
    expText.innerHTML = "Click a region to spotlight it. In this geology context, sets represent mineral-forming environments or processes; a mineral belongs to a set if its label lies inside that circle.";
    expListWrap.style.display = "none";
    expListWrap.innerHTML = "";
  }

  function updateInfo(hl, mem){
    const expr = prettyExpr(hl.kind, hl.indices);
    const count = countForHighlight(hl.kind, hl.indices, mem.countsByMask, mem.total);

    expExpr.textContent = expr;
    expCount.textContent = `(${count} element${count===1?'':'s'})`;

    // Build chips list
    const items = [];
    for (let i=0; i<state.elements.length; i++){
      if (elementInRegion(mem.perElement[i], hl.kind, hl.indices)){
        items.push(state.elements[i].label);
      }
    }
    expListWrap.innerHTML = items.map(t => `<span class="tag">${t}</span>`).join("");
    expListWrap.style.display = items.length ? "flex" : "none";

    // Contextual text
    const name = (i) => state.sets[i]?.name || `Set ${i+1}`;
    const id   = (i) => state.sets[i]?.id   || `S${i+1}`;
    let desc = "";
    if (hl.kind === 'single'){
      desc = `Minerals inside <strong>${name(hl.indices[0])}</strong> (${id(hl.indices[0])}).`;
    } else if (hl.kind === 'pair'){
      desc = `Minerals common to <strong>${name(hl.indices[0])}</strong> and <strong>${name(hl.indices[1])}</strong> — ${id(hl.indices[0])} ∩ ${id(hl.indices[1])}.`;
    } else if (hl.kind === 'diff'){
      desc = `Minerals in <strong>${name(hl.indices[0])}</strong> but not in <strong>${name(hl.indices[1])}</strong> — ${id(hl.indices[0])} \\ ${id(hl.indices[1])}.`;
    } else if (hl.kind === 'union'){
      const human = hl.indices.map(i => `${name(i)} (${id(i)})`).join(" or ");
      desc = `Minerals in ${human} — union.`;
    } else if (hl.kind === 'triple'){
      desc = `Minerals belonging to all three sets — triple intersection.`;
    } else if (hl.kind === 'outside'){
      const unionIds = state.sets.map(s=>s.id).join(" ∪ ");
      desc = `Minerals outside all sets, i.e., complement U \\ (${unionIds}).`;
    } else if (hl.kind === 'all'){
      const unionNames = state.sets.map(s=>`${s.name} (${s.id})`).join(", ");
      desc = `Minerals in the union of all sets (${unionNames}).`;
    }
    desc += ` A mineral is a member if its label lies inside that set’s circle.`;
    expText.innerHTML = desc;
  }

  // ---------- UI builders ----------
  function rebuildSetChips(){
    const setsChipsEl = document.getElementById("setsChips");
    setsChipsEl.innerHTML = "";
    state.sets.forEach((s) => {
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.innerHTML = `<span class="dot" style="background:${s.color}"></span><strong>${s.name}</strong> <small>(${s.id})</small>`;
      chip.title = `Set ${s.name} [${s.id}]`;
      setsChipsEl.appendChild(chip);
    });

    // Table header
    const theadRowEl = document.getElementById("theadRow");
    while (theadRowEl.children.length > 2) theadRowEl.removeChild(theadRowEl.lastChild);
    state.sets.forEach(s => {
      const th = document.createElement("th");
      th.textContent = s.name;
      theadRowEl.appendChild(th);
    });
  }

  function updateRegionsAndTable(){
    const { countsByMask, singles, pairs, diffs, unions2, triples, perElement, total } = memberships();
    const n = state.sets.length;
    const outside = countsByMask[0];

    const regionsEl = document.getElementById("regions");
    regionsEl.innerHTML = `<h2>Regions &amp; Intersections</h2>`;

    const addSubhead = (text) => {
      const row = document.createElement("div");
      row.className = "row subhead";
      row.textContent = text;
      regionsEl.appendChild(row);
    };

    const addRow = (lhsHtml, k, kind=null, indices=[]) => {
      const row = document.createElement("div");
      row.className = "row";
      row.innerHTML = `<div class="lhs">${lhsHtml}</div><div class="k">${k}</div>`;
      if (kind){
        row.dataset.kind = kind;
        row.dataset.indices = indices.join(",");
        row.title = "Click to highlight this region";
        row.addEventListener("click", () => {
          const same = state.highlight &&
                       state.highlight.kind === kind &&
                       JSON.stringify(state.highlight.indices) === JSON.stringify(indices);
          state.highlight = same ? null : {kind, indices};
          document.querySelectorAll(".summary .row").forEach(el => el.classList.remove("selected"));
          if (!same) row.classList.add("selected");
          if (same) { clearHighlightChip(); }
          requestDraw();
        });
      } else { row.style.cursor = "default"; }
      if (state.highlight && state.highlight.kind === kind &&
          JSON.stringify(state.highlight.indices) === JSON.stringify(indices)){
        row.classList.add("selected");
      }
      regionsEl.appendChild(row);
    };

    // Totals
    addSubhead("Totals");
    addRow(`<span class="badge">Total minerals</span>`, total, null, []);
    addRow(`<span class="badge">Outside all sets</span>`, outside, "outside", []);
    addRow(`<span class="badge">Union (all sets)</span>`, total - outside, "all", []);

    // Singles
    addSubhead("Singles (Inside A)");
    singles.forEach((cnt, i) => {
      const s = state.sets[i];
      addRow(`<span class="badge"><span class="dot" style="background:${s.color}"></span>${s.name}</span>`, cnt, "single", [i]);
    });

    // Intersections
    if (pairs.length){
      addSubhead("Intersections (A ∩ B)");
      pairs.forEach(({i,j,count}) => {
        const a = state.sets[i], b = state.sets[j];
        const dot = `<span class="dot" style="background:${mixColors([a.color,b.color])}"></span>`;
        addRow(`${dot}<code>${a.id} ∩ ${b.id}</code>`, count, "pair", [i,j]);
      });
    }

    // Differences
    if (diffs.length){
      addSubhead("Differences (A \\ B)");
      diffs.forEach(({i,j,count}) => {
        const a = state.sets[i], b = state.sets[j];
        addRow(`<span class="dot" style="background:${a.color}"></span><code>${a.id} \\ ${b.id}</code>`,
               count, "diff", [i,j]);
      });
    }

    // Unions
    if (unions2.length){
      addSubhead("Unions (A ∪ B)");
      unions2.forEach(({i,j,count}) => {
        const a = state.sets[i], b = state.sets[j];
        const dot = `<span class="dot" style="background:${mixColors([a.color,b.color])}"></span>`;
        addRow(`${dot}<code>${a.id} ∪ ${b.id}</code>`, count, "union", [i,j]);
      });
    }

    // Triple intersections
    if (triples.length){
      addSubhead("Triple Intersections (A ∩ B ∩ C)");
      triples.forEach(({i,j,k,count}) => {
        const a = state.sets[i], b = state.sets[j], c = state.sets[k];
        const dot = `<span class="dot" style="background:${mixColors([a.color,b.color,c.color])}"></span>`;
        addRow(`${dot}<code>${a.id} ∩ ${b.id} ∩ ${c.id}</code>`, count, "triple", [i,j,k]);
      });
    }

    // Elements table
    const tbodyEl = document.getElementById("tbody");
    tbodyEl.innerHTML = "";
    const idByIndex = state.sets.map(s => s.id);

    state.elements.forEach((e, idx) => {
      const tr = document.createElement("tr");

      const name = document.createElement("td");
      name.textContent = e.label;
      tr.appendChild(name);

      // status cell
      const mask = perElement[idx];
      const got = [];
      for (let si=0; si<n; si++) if (mask & (1<<si)) got.push(idByIndex[si]);
      const want = state.answerKey[e.id] || [];
      const ok = sameSet(got, want);
      const tdStatus = document.createElement("td");
      tdStatus.innerHTML = ok ? `<span class="ok">✓</span>` : `<span class="bad">✗</span>`;
      tr.appendChild(tdStatus);

      // membership cells
      for (let si=0; si<n; si++){
        const td = document.createElement("td");
        td.className = "k";
        td.textContent = (mask & (1<<si)) ? "✓" : "—";
        tr.appendChild(td);
      }
      tbodyEl.appendChild(tr);
    });
  }

  // ---------- Interactions ----------
  function onPointerDown(ev){
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
    const pick = pickAt(x,y);
    if (!pick) return;

    if (pick.type === "set" && document.getElementById("lockSets").checked) return;
    if (pick.type === "element" && document.getElementById("lockElements").checked) return;

    state.drag = {type: pick.type, index: pick.index, dx:0, dy:0};
    if (pick.type === "set"){
      const s = state.sets[pick.index];
      state.drag.dx = pxX(s.x) - x;
      state.drag.dy = pxY(s.y) - y;
    } else {
      const e = state.elements[pick.index];
      state.drag.dx = pxX(e.x) - x;
      state.drag.dy = pxY(e.y) - y;
    }
    ev.preventDefault();
  }

  function onPointerMove(ev){
    if (!state.drag) return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
    const nx = nX(x + state.drag.dx);
    const ny = nY(y + state.drag.dy);

    if (state.drag.type === "set"){
      const s = state.sets[state.drag.index];
      const rpx = s.r * S();
      const minX = rpx / canvas.clientWidth;
      const maxX = 1 - minX;
      const minY = rpx / canvas.clientHeight;
      const maxY = 1 - minY;
      s.x = Math.max(minX, Math.min(maxX, nx));
      s.y = Math.max(minY, Math.min(maxY, ny));
    } else {
      const e = state.elements[state.drag.index];
      e.x = nx; e.y = ny;
    }
    requestDraw();
    ev.preventDefault();
  }

  function onPointerUp(){ state.drag = null; }

  function onWheel(ev){
    if (document.getElementById("lockSets").checked) return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
    const pick = pickAt(x,y);
    if (!pick || pick.type !== "set") return;

    const s = state.sets[pick.index];
    const factor = (ev.deltaY < 0) ? 1.05 : 0.95;
    s.r = Math.max(0.06, Math.min(0.5, s.r * factor));

    // keep inside bounds
    const rpx = s.r * S();
    const minX = rpx / canvas.clientWidth;
    const maxX = 1 - minX;
    const minY = rpx / canvas.clientHeight;
    const maxY = 1 - minY;
    s.x = Math.max(minX, Math.min(maxX, s.x));
    s.y = Math.max(minY, Math.min(maxY, s.y));

    requestDraw();
    ev.preventDefault();
  }

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && state.highlight){
      state.highlight = null;
      document.querySelectorAll(".summary .row").forEach(el => el.classList.remove("selected"));
      clearHighlightChip();
      defaultInfo();
      requestDraw();
    }
  });

  // ---------- Puzzle I/O ----------
  async function newPuzzle(){
    const seed = Date.now();
    const res = await fetch(`/api/puzzle?seed=${seed}`);
    const data = await res.json();
    state.universe = data.universe;
    state.sets = data.sets;
    state.elements = data.elements;
    state.answerKey = data.answer_key || {};
    state.solution = data.solution || null;
    document.getElementById("uName").textContent = state.universe.name || "Universe (U)";

    document.querySelectorAll(".summary .row").forEach(el => el.classList.remove("selected"));
    state.highlight = null;
    rebuildSetChips();
    defaultInfo();
    requestDraw();
    updateRegionsAndTable();
  }

  // ---------- Loop ----------
  function loop(){
    if (state.needsDraw){
      draw();
      updateRegionsAndTable();
    }
    requestAnimationFrame(loop);
  }

  // ---------- Wire up ----------
  window.addEventListener("resize", resizeCanvas);
  canvas.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove);
  window.addEventListener("pointerup", onPointerUp);
  canvas.addEventListener("wheel", onWheel, {passive:false});

  document.getElementById("btnNewPuzzle").addEventListener("click", newPuzzle);
  document.getElementById("showLabels").addEventListener("change", requestDraw);

  // ---------- Boot ----------
  (async function boot(){
    resizeCanvas();
    await newPuzzle();
    loop();
  })();
})();
</script>
{% endblock %}
